Unit db;
interface
uses
  Windows;
(* DO NOT EDIT: automatically built by dist/s_windows. *)
(*
 * See the file LICENSE for redistribution information.
 *
 * Copyright (c) 1996-2006
 *	Oracle Corporation.  All rights reserved.
 *
 * $Id: db.in,v 12.108 2006/09/13 14:53:37 mjc Exp $
 *
 * db.h include file layout:
 *	General.
 *	Database Environment.
 *	Locking subsystem.
 *	Logging subsystem.
 *	Shared buffer cache (mpool) subsystem.
 *	Transaction subsystem.
 *	Access methods.
 *	Access method cursors.
 *	Dbm/Ndbm, Hsearch historic interfaces.
 *)


(*
 * Turn off inappropriate compiler warnings
 *)

//  	__P(protos)	protos

(*
 * Berkeley DB version information.
 *)
 Const
   DB_VERSION_MAJOR    = 4;
   DB_VERSION_MINOR    = 5;
   DB_VERSION_PATCH    = 20;
   DB_VERSION_STRING   = 'Berkeley DB 4.5.20: (September 20, 2006)';

(*
 * !!!
 * Berkeley DB uses specifically sized types.  If they're not provided by
 * the system, type them here.
 *
 * We protect them against multiple inclusion using __BIT_TYPES_DEFINED__,
 * as does BIND and Kerberos, since we don't know for sure what #include
 * files the user is using.
 *
 * !!!
 * We also provide the standard u_int, u_long etc., if they're not provided
 * by the system.
 *)
type
  int        = integer;
  u_int8_t   = byte ;
  int16_t    = smallint ;
  u_int16_t  = word ;
  int32_t    = integer ;
  u_int32_t  = DWORD ;
  int64_t    = int64 ;
  u_int64_t  = int64 ;

type
  u_char     = Byte ;
  u_short    = Word ;
  u_int      = DWORD ;
  u_long     = DWORD;

{$ifdef _WIN64}
type
  ssize_t    = int64_t ;
{$else}
type
  ssize_t    = int32_t ;
{$endif}

(*
 * uintmax_t --
 * Largest unsigned type, used to align structures in memory.  We don't store
 * floating point types in structures, so integral types should be sufficient
 * (and we don't have to worry about systems that store floats in other than
 * power-of-2 numbers of bytes).  Additionally this fixes compilers that rewrite
 * structure assignments and ANSI C memcpy calls to be in-line instructions
 * that happen to require alignment.
 *
 * uintptr_t --
 * Unsigned type that's the same size as a pointer.  There are places where
 * DB modifies pointers by discarding the bottom bits to guarantee alignment.
 * We can't use uintmax_t, it may be larger than the pointer, and compilers
 * get upset about that.  So far we haven't run on any machine where there's
 * no unsigned type the same size as a pointer -- here's hoping.
 *)
type
  uintmax_t = u_int64_t ;
{$ifdef _WIN64}
type
  uintptr_t = u_int64_t ;
{$else}
type
  uintptr_t = u_int32_t ;
{$endif}

(*
 * Sequences are only available on machines with 64-bit integral types.
 *)
type
  db_seq_t = int64_t ;

(* Thread and process identification. *)
type
  db_threadid_t = u_int32_t ;
  pid_t = int ;

(* Basic types that are exported or quasi-exported. *)
type
  db_pgno_t= u_int32_t	;	(* Page number type. *)
  db_indx_t= u_int16_t	;	(* Page offset type. *)
const
  DB_MAX_PAGES	= $ffffffff;	(* >= # of pages in a file *)

type
  db_recno_t= u_int32_t	;	(* Record number type. *)
const
  DB_MAX_RECORDS = $ffffffff;	(* >= # of records in a tree *)

type
  db_timeout_t= u_int32_t	;	(* Type of a timeout. *)

(*
 * Region offsets are the difference between a pointer in a region and the
 * region's base address.  With private environments, both addresses are the
 * result of calling malloc, and we can't assume anything about what malloc
 * will return, so region offsets have to be able to hold differences between
 * arbitrary pointers.
 *)
type
  roff_t= uintptr_t	;

(*
 * Forward structure declarations, so we can declare pointers and
 * applications can get type checking.
 *)
 {
struct __db;		type struct __db DB;
struct __db_bt_stat;	type struct __db_bt_stat DB_BTREE_STAT;
struct __db_cipher;	type struct __db_cipher DB_CIPHER;
struct __db_compact;	type struct __db_compact DB_COMPACT;
struct __db_dbt;	type struct __db_dbt DBT;
struct __db_env;	type struct __db_env DB_ENV;
struct __db_h_stat;	type struct __db_h_stat DB_HASH_STAT;
struct __db_ilock;	type struct __db_ilock DB_LOCK_ILOCK;
struct __db_lock_stat;	type struct __db_lock_stat DB_LOCK_STAT;
struct __db_lock_u;	type struct __db_lock_u DB_LOCK;
struct __db_lockreq;	type struct __db_lockreq DB_LOCKREQ;
struct __db_locktab;	type struct __db_locktab DB_LOCKTAB;
struct __db_log;	type struct __db_log DB_LOG;
struct __db_log_cursor;	type struct __db_log_cursor DB_LOGC;
struct __db_log_stat;	type struct __db_log_stat DB_LOG_STAT;
struct __db_lsn;	type struct __db_lsn DB_LSN;
struct __db_mpool;	type struct __db_mpool DB_MPOOL;
struct __db_mpool_fstat;type struct __db_mpool_fstat DB_MPOOL_FSTAT;
struct __db_mpool_stat;	type struct __db_mpool_stat DB_MPOOL_STAT;
struct __db_mpoolfile;	type struct __db_mpoolfile DB_MPOOLFILE;
struct __db_mutex_stat;	type struct __db_mutex_stat DB_MUTEX_STAT;
struct __db_mutex_t;	type struct __db_mutex_t DB_MUTEX;
struct __db_mutexmgr;	type struct __db_mutexmgr DB_MUTEXMGR;
struct __db_preplist;	type struct __db_preplist DB_PREPLIST;
struct __db_qam_stat;	type struct __db_qam_stat DB_QUEUE_STAT;
struct __db_rep;	type struct __db_rep DB_REP;
struct __db_rep_stat;	type struct __db_rep_stat DB_REP_STAT;
struct __db_repmgr_site; \
			type struct __db_repmgr_site DB_REPMGR_SITE;
struct __db_seq_record; type struct __db_seq_record DB_SEQ_RECORD;
struct __db_seq_stat;	type struct __db_seq_stat DB_SEQUENCE_STAT;
struct __db_sequence;	type struct __db_sequence DB_SEQUENCE;
struct __db_txn;	type struct __db_txn DB_TXN;
struct __db_txn_active;	type struct __db_txn_active DB_TXN_ACTIVE;
struct __db_txn_stat;	type struct __db_txn_stat DB_TXN_STAT;
struct __db_txnmgr;	type struct __db_txnmgr DB_TXNMGR;
struct __dbc;		type struct __dbc DBC;
struct __dbc_internal;	type struct __dbc_internal DBC_INTERNAL;
struct __fh_t;		type struct __fh_t DB_FH;
struct __fname;		type struct __fname FNAME;
struct __key_range;	type struct __key_range DB_KEY_RANGE;
struct __mpoolfile;	type struct __mpoolfile MPOOLFILE;

(* Key/data structure -- a Data-Base Thang. *)
const
  DB_DBT_APPMALLOC     = $001;	(* Callback allocated memory. *)
  DB_DBT_ISSET	       = $002;	(* Lower level calls set value. *)
  DB_DBT_MALLOC	       = $004;	(* Return in malloc'd memory. *)
  DB_DBT_PARTIAL       = $008;	(* Partial put/get. *)
  DB_DBT_REALLOC       = $010;	(* Return in realloc'd memory. *)
  DB_DBT_USERCOPY      = $020;	(* Use the user-supplied callback. *)
  DB_DBT_USERMEM       = $040;	(* Return in user's memory. *)
  DB_DBT_DUPOK	       = $080;	(* Insert if duplicate. *)
type
  __db_dbt = record
    Pointer data;			(* Key/data *)
    u_int32_t size;			(* key/data length *)

    u_int32_t ulen;			(* RO: length of user buffer. *)
    u_int32_t dlen;			(* RO: get/put record length. *)
    u_int32_t doff;			(* RO: get/put record offset. *)

    Pointer app_data;

    u_int32_t flags;
  end;

(*
 * Common flags --
 *	Interfaces which use any of these common flags should never have
 *	interface specific flags in this range.
 *)
 const
   DB_CREATE	      =$0000001; (* Create file as necessary. *)
   DB_DURABLE_UNKNOWN =$0000002; (* Durability on open (internal). *)
   DB_FORCE	      =$0000004; (* Force (anything). *)
   DB_MULTIVERSION    =$0000008; (* Multiversion concurrency control. *)
   DB_NOMMAP	      =$0000010; (* Don't mmap underlying file. *)
   DB_RDONLY	      =$0000020; (* Read-only (O_RDONLY). *)
   DB_RECOVER	      =$0000040; (* Run normal recovery. *)
   DB_THREAD	      =$0000080; (* Applications are threaded. *)
   DB_TRUNCATE	      =$0000100; (* Discard existing DB (O_TRUNC). *)
   DB_TXN_NOSYNC      =$0000200; (* Do not sync log on commit. *)
   DB_TXN_NOT_DURABLE =$0000400; (* Do not log changes. *)
   DB_TXN_WRITE_NOSYNC=$0000800; (* Write the log but don't sync. *)
   DB_USE_ENVIRON     =$0001000; (* Use the environment. *)
   DB_USE_ENVIRON_ROOT=$0002000; (* Use the environment if root. *)

(*
 * Common flags --
 *	Interfaces which use any of these common flags should never have
 *	interface specific flags in this range.
 *
 * DB_AUTO_COMMIT:
 *	DB_ENV->set_flags, DB->open
 *      (Note: until the 4.3 release, legal to DB->associate, DB->del,
 *	DB->put, DB->remove, DB->rename and DB->truncate, and others.)
 * DB_READ_COMMITTED:
 *	DB->cursor, DB->get, DB->join, DBcursor->c_get, DB_ENV->txn_begin
 * DB_READ_UNCOMMITTED:
 *	DB->cursor, DB->get, DB->join, DB->open, DBcursor->c_get,
 *	DB_ENV->txn_begin
 * DB_TXN_SNAPSHOT:
 *	DB_ENV->set_flags, DB_ENV->txn_begin, DB->cursor
 *
 * !!!
 * The DB_READ_COMMITTED and DB_READ_UNCOMMITTED bit masks can't be changed
 * without also changing the masks for the flags that can be OR'd into DB
 * access method and cursor operation values.
 *)
const
  DB_AUTO_COMMIT      =$02000000;(* Implied transaction. *)

  DB_READ_COMMITTED   =$04000000;(* Degree 2 isolation. *)
  DB_DEGREE_2	      =$04000000;(*	Historic name. *)

  DB_READ_UNCOMMITTED =$08000000;(* Degree 1 isolation. *)
  DB_DIRTY_READ	      =$08000000;(*	Historic name. *)

  DB_TXN_SNAPSHOT     =$10000000;(* Snapshot isolation. *)

(*
 * Flags common to db_env_create and db_create.
 *)
  DB_CXX_NO_EXCEPTIONS  $0000001	(* C++: return error values. *)

(*
 * Flags private to db_env_create.
 *	   Shared flags up to $0000001 *)
  DB_RPCCLIENT	      $0000002	(* An RPC client environment. *)

(*
 * Flags private to db_create.
 *	   Shared flags up to $0000001 *)
  DB_XA_CREATE	      $0000002	(* Open in an XA environment. *)

(*
 * Flags private to DB_ENV->open.
 *	   Shared flags up to $0002000 *)
  DB_INIT_CDB	      $0004000	(* Concurrent Access Methods. *)
  DB_INIT_LOCK	      $0008000	(* Initialize locking. *)
  DB_INIT_LOG	      $0010000	(* Initialize logging. *)
  DB_INIT_MPOOL	      $0020000	(* Initialize mpool. *)
  DB_INIT_REP	      $0040000	(* Initialize replication. *)
  DB_INIT_TXN	      $0080000	(* Initialize transactions. *)
  DB_LOCKDOWN	      $0100000	(* Lock memory into physical core. *)
  DB_PRIVATE	      $0200000	(* DB_ENV is process local. *)
  DB_RECOVER_FATAL      $0400000	(* Run catastrophic recovery. *)
  DB_REGISTER	      $0800000	(* Multi-process registry. *)
  DB_SYSTEM_MEM	      $1000000	(* Use system-backed memory. *)

  DB_JOINENV	      $0	(* Compatibility. *)

(*
 * Flags private to DB->open.
 *	   Shared flags up to $0002000 *)
  DB_EXCL		      $0004000	(* Exclusive open (O_EXCL). *)
  DB_FCNTL_LOCKING      $0008000	(* UNDOC: fcntl(2) locking. *)
  DB_NO_AUTO_COMMIT     $0010000	(* Override env-wide AUTOCOMMIT. *)
  DB_RDWRMASTER	      $0020000	(* UNDOC: allow subdb master open R/W *)
  DB_WRITEOPEN	      $0040000	(* UNDOC: open with write lock. *)

(*
 * Flags private to DB->associate.
 *	   Shared flags up to $0002000 *)
  DB_IMMUTABLE_KEY      $0004000	(* Secondary key is immutable. *)
(*	      Shared flags at $1000000 *)

(*
 * Flags private to DB_ENV->txn_begin.
 *	   Shared flags up to $0002000 *)
  DB_TXN_NOWAIT	      $0004000	(* Do not wait for locks in this TXN. *)
  DB_TXN_SYNC	      $0008000	(* Always sync log on commit. *)

(*
 * Flags private to DB_ENV->set_encrypt.
 *)
  DB_ENCRYPT_AES	      $0000001	(* AES, assumes SHA1 checksum *)

(*
 * Flags private to DB_ENV->set_flags.
 *	   Shared flags up to $00002000 *)
  DB_CDB_ALLDB	      $00004000(* Set CDB locking per environment. *)
  DB_DIRECT_DB	      $00008000(* Don't buffer databases in the OS. *)
  DB_DIRECT_LOG	      $00010000(* Don't buffer log files in the OS. *)
  DB_DSYNC_DB	      $00020000(* Set O_DSYNC on the databases. *)
  DB_DSYNC_LOG	      $00040000(* Set O_DSYNC on the log. *)
  DB_LOG_AUTOREMOVE     $00080000(* Automatically remove log files. *)
  DB_LOG_INMEMORY       $00100000(* Store logs in buffers in memory. *)
  DB_NOLOCKING	      $00200000(* Set locking/mutex behavior. *)
  DB_NOPANIC	      $00400000(* Set panic state per DB_ENV. *)
  DB_OVERWRITE	      $00800000(* Overwrite unlinked region files. *)
  DB_PANIC_ENVIRONMENT  $01000000(* Set panic state per environment. *)
(*	      Shared flags at $02000000 *)
(*	      Shared flags at $04000000 *)
(*	      Shared flags at $08000000 *)
(*	      Shared flags at $10000000 *)
  DB_REGION_INIT	      $20000000(* Page-fault regions on open. *)
  DB_TIME_NOTGRANTED    $40000000(* Return NOTGRANTED on timeout. *)
  DB_YIELDCPU	      $80000000(* Yield the CPU (a lot). *)

(*
 * Flags private to DB->set_feedback's callback.
 *)
  DB_UPGRADE	      $0000001	(* Upgrading. *)
  DB_VERIFY	      $0000002	(* Verifying. *)

(*
 * Flags private to DB->compact.
 *	   Shared flags up to $00002000
 *)
  DB_FREELIST_ONLY      $00004000 (* Just sort and truncate. *)
  DB_FREE_SPACE         $00008000 (* Free space . *)
  DB_COMPACT_FLAGS      \
     (DB_FREELIST_ONLY | DB_FREE_SPACE)

(*
 * Flags private to DB_MPOOLFILE->open.
 *	   Shared flags up to $0002000 *)
  DB_DIRECT	      $0004000	(* Don't buffer the file in the OS. *)
  DB_EXTENT	      $0008000	(* internal: dealing with an extent. *)
  DB_ODDFILESIZE	      $0010000	(* Truncate file to N * pgsize. *)

(*
 * Flags private to DB->set_flags.
 *	   Shared flags up to $00002000 *)
  DB_CHKSUM	      $00004000 (* Do checksumming *)
  DB_DUP		      $00008000 (* Btree, Hash: duplicate keys. *)
  DB_DUPSORT	      $00010000 (* Btree, Hash: duplicate keys. *)
  DB_ENCRYPT	      $00020000 (* Btree, Hash: duplicate keys. *)
  DB_INORDER	      $00040000 (* Queue: strict ordering on consume *)
  DB_RECNUM	      $00080000 (* Btree: record numbers. *)
  DB_RENUMBER	      $00100000 (* Recno: renumber on insert/delete. *)
  B_REVSPLITOFF	      $00200000 (* Btree: turn off reverse splits. *)
  DB_SNAPSHOT	      $00400000 (* Recno: snapshot the input. *)

(*
 * Flags private to the DB_ENV->stat_print, DB->stat and DB->stat_print methods.
 *)
  DB_FAST_STAT	      $0000001 (* Don't traverse the database. *)
  DB_STAT_ALL	      $0000002	(* Print: Everything. *)
  DB_STAT_CLEAR	      $0000004	(* Clear stat after returning values. *)
  DB_STAT_LOCK_CONF     $0000008	(* Print: Lock conflict matrix. *)
  DB_STAT_LOCK_LOCKERS  $0000010	(* Print: Lockers. *)
  DB_STAT_LOCK_OBJECTS  $0000020	(* Print: Lock objects. *)
  DB_STAT_LOCK_PARAMS   $0000040	(* Print: Lock parameters. *)
  DB_STAT_MEMP_HASH     $0000080	(* Print: Mpool hash buckets. *)
  DB_STAT_NOERROR       $0000100 (* Internal: continue on error. *)
  DB_STAT_SUBSYSTEM     $0000200 (* Print: Subsystems too. *)

(*
 * Flags private to DB->join.
 *)
  DB_JOIN_NOSORT	      $0000001	(* Don't try to optimize join. *)

(*
 * Flags private to DB->verify.
 *)
  DB_AGGRESSIVE	      $0000001	(* Salvage whatever could be data.*)
  DB_NOORDERCHK	      $0000002	(* Skip sort order/hashing check. *)
  DB_ORDERCHKONLY	      $0000004	(* Only perform the order check. *)
  DB_PR_PAGE	      $0000008	(* Show page contents (-da). *)
  DB_PR_RECOVERYTEST    $0000010	(* Recovery test (-dr). *)
  DB_PRINTABLE	      $0000020	(* Use printable format for salvage. *)
  DB_SALVAGE	      $0000040	(* Salvage what looks like data. *)
  DB_UNREF	      $0000080	(* Report unreferenced pages. *)
(*
 * !!!
 * These must not go over $8000, or they will collide with the flags
 * used by __bam_vrfy_subtree.
 *)

(*
 * Flags private to DB->rep_set_transport's send callback.
 *)
  DB_REP_ANYWHERE	      $0000001	(* Message can be serviced anywhere. *)
  DB_REP_NOBUFFER	      $0000002	(* Do not buffer this message. *)
  DB_REP_PERMANENT      $0000004	(* Important--app. may want to flush. *)
  DB_REP_REREQUEST      $0000008	(* This msg already been requested. *)

(*******************************************************
 * Mutexes.
 *******************************************************)
type u_int32_t	db_mutex_t;

(*
 * Flag arguments for DbEnv.mutex_alloc, DbEnv.is_alive and for the
 * DB_MUTEX structure.
 *)
  DB_MUTEX_ALLOCATED	$01	(* Mutex currently allocated. *)
  DB_MUTEX_LOCKED		$02	(* Mutex currently locked. *)
  DB_MUTEX_LOGICAL_LOCK	$04	(* Mutex backs a database lock. *)
  DB_MUTEX_PROCESS_ONLY	$08	(* Mutex private to a process. *)
  DB_MUTEX_SELF_BLOCK	$10	(* Must be able to block self. *)

type
  __db_mutex_stat = record
    (* The following fields are maintained in the region's copy. *)
    u_int32_t st_mutex_align;	(* Mutex alignment *)
    u_int32_t st_mutex_tas_spins;	(* Mutex test-and-set spins *)
    u_int32_t st_mutex_cnt;		(* Mutex count *)
    u_int32_t st_mutex_free;	(* Available mutexes *)
    u_int32_t st_mutex_inuse;	(* Mutexes in use *)
    u_int32_t st_mutex_inuse_max;	(* Maximum mutexes ever in use *)

    (* The following fields are filled-in from other places. *)
    u_int32_t st_region_wait;	(* Region lock granted after wait. *)
    u_int32_t st_region_nowait;	(* Region lock granted without wait. *)
    roff_t	  st_regsize;		(* Region size. *)
  end;

(* This is the length of the buffer passed to DB_ENV->thread_id_string() *)
const
  DB_THREADID_STRLEN	128

(*******************************************************
 * Locking.
 *******************************************************)
  DB_LOCKVERSION	1

  DB_FILE_ID_LEN		20	(* Unique file ID length. *)

(*
 * Deadlock detector modes; used in the DB_ENV structure to configure the
 * locking subsystem.
 *)
  DB_LOCK_NORUN		0
  DB_LOCK_DEFAULT		1	(* Default policy. *)
  DB_LOCK_EXPIRE		2	(* Only expire locks, no detection. *)
  DB_LOCK_MAXLOCKS	3	(* Select locker with max locks. *)
  DB_LOCK_MAXWRITE	4	(* Select locker with max writelocks. *)
  DB_LOCK_MINLOCKS	5	(* Select locker with min locks. *)
  DB_LOCK_MINWRITE	6	(* Select locker with min writelocks. *)
  DB_LOCK_OLDEST		7	(* Select oldest locker. *)
  DB_LOCK_RANDOM		8	(* Select random locker. *)
  DB_LOCK_YOUNGEST	9	(* Select youngest locker. *)

(* Flag values for lock_vec(), lock_get(). *)
  DB_LOCK_ABORT		$001	(* Internal: Lock during abort. *)
  DB_LOCK_NOWAIT		$002	(* Don't wait on unavailable lock. *)
  DB_LOCK_RECORD		$004	(* Internal: record lock. *)
  DB_LOCK_SET_TIMEOUT	$008	(* Internal: set lock timeout. *)
  DB_LOCK_SWITCH		$010	(* Internal: switch existing lock. *)
  DB_LOCK_UPGRADE		$020	(* Internal: upgrade existing lock. *)

(*
 * Simple R/W lock modes and for multi-granularity intention locking.
 *
 * !!!
 * These values are NOT random, as they are used as an index into the lock
 * conflicts arrays, i.e., DB_LOCK_IWRITE must be == 3, and DB_LOCK_IREAD
 * must be == 4.
 *)
type enum {
	DB_LOCK_NG=0,			(* Not granted. *)
	DB_LOCK_READ=1,			(* Shared/read. *)
	DB_LOCK_WRITE=2,		(* Exclusive/write. *)
	DB_LOCK_WAIT=3,			(* Wait for event *)
	DB_LOCK_IWRITE=4,		(* Intent exclusive/write. *)
	DB_LOCK_IREAD=5,		(* Intent to share/read. *)
	DB_LOCK_IWR=6,			(* Intent to read and write. *)
	DB_LOCK_READ_UNCOMMITTED=7,	(* Degree 1 isolation. *)
	DB_LOCK_WWRITE=8		(* Was Written. *)
} db_lockmode_t;

(*
 * Request types.
 *)
type enum {
	DB_LOCK_DUMP=0,			(* Display held locks. *)
	DB_LOCK_GET=1,			(* Get the lock. *)
	DB_LOCK_GET_TIMEOUT=2,		(* Get lock with a timeout. *)
	DB_LOCK_INHERIT=3,		(* Pass locks to parent. *)
	DB_LOCK_PUT=4,			(* Release the lock. *)
	DB_LOCK_PUT_ALL=5,		(* Release locker's locks. *)
	DB_LOCK_PUT_OBJ=6,		(* Release locker's locks on obj. *)
	DB_LOCK_PUT_READ=7,		(* Release locker's read locks. *)
	DB_LOCK_TIMEOUT=8,		(* Force a txn to timeout. *)
	DB_LOCK_TRADE=9,		(* Trade locker ids on a lock. *)
	DB_LOCK_UPGRADE_WRITE=10	(* Upgrade writes for dirty reads. *)
} db_lockop_t;

(*
 * Status of a lock.
 *)
type enum  {
	DB_LSTAT_ABORTED=1,		(* Lock belongs to an aborted txn. *)
	DB_LSTAT_EXPIRED=2,		(* Lock has expired. *)
	DB_LSTAT_FREE=3,		(* Lock is unallocated. *)
	DB_LSTAT_HELD=4,		(* Lock is currently held. *)
	DB_LSTAT_PENDING=5,		(* Lock was waiting and has been
					 * promoted; waiting for the owner
					 * to run and upgrade it to held. *)
	DB_LSTAT_WAITING=6		(* Lock is on the wait queue. *)
}db_status_t;

(* Lock statistics structure. *)
struct __db_lock_stat {
	u_int32_t st_id;		(* Last allocated locker ID. *)
	u_int32_t st_cur_maxid;		(* Current maximum unused ID. *)
	u_int32_t st_maxlocks;		(* Maximum number of locks in table. *)
	u_int32_t st_maxlockers;	(* Maximum num of lockers in table. *)
	u_int32_t st_maxobjects;	(* Maximum num of objects in table. *)
	int	  st_nmodes;		(* Number of lock modes. *)
	u_int32_t st_nlocks;		(* Current number of locks. *)
	u_int32_t st_maxnlocks;		(* Maximum number of locks so far. *)
	u_int32_t st_nlockers;		(* Current number of lockers. *)
	u_int32_t st_maxnlockers;	(* Maximum number of lockers so far. *)
	u_int32_t st_nobjects;		(* Current number of objects. *)
	u_int32_t st_maxnobjects;	(* Maximum number of objects so far. *)
	u_int32_t st_nrequests;		(* Number of lock gets. *)
	u_int32_t st_nreleases;		(* Number of lock puts. *)
	u_int32_t st_nupgrade;		(* Number of lock upgrades. *)
	u_int32_t st_ndowngrade;	(* Number of lock downgrades. *)
	u_int32_t st_lock_wait;		(* Lock conflicts w/ subsequent wait *)
	u_int32_t st_lock_nowait;	(* Lock conflicts w/o subsequent wait *)
	u_int32_t st_ndeadlocks;	(* Number of lock deadlocks. *)
	db_timeout_t st_locktimeout;	(* Lock timeout. *)
	u_int32_t st_nlocktimeouts;	(* Number of lock timeouts. *)
	db_timeout_t st_txntimeout;	(* Transaction timeout. *)
	u_int32_t st_ntxntimeouts;	(* Number of transaction timeouts. *)
	u_int32_t st_region_wait;	(* Region lock granted after wait. *)
	u_int32_t st_region_nowait;	(* Region lock granted without wait. *)
	roff_t	  st_regsize;		(* Region size. *)
};

(*
 * DB_LOCK_ILOCK --
 *	Internal DB access method lock.
 *)
struct __db_ilock {
	db_pgno_t pgno;			(* Page being locked. *)
	u_int8_t fileid[DB_FILE_ID_LEN];(* File id. *)
 	DB_HANDLE_LOCK	1
 	DB_RECORD_LOCK	2
 	DB_PAGE_LOCK	3
	u_int32_t type;			(* Type of lock. *)
};

(*
 * DB_LOCK --
 *	The structure is allocated by the caller and filled in during a
 *	lock_get request (or a lock_vec/DB_LOCK_GET).
 *)
struct __db_lock_u {
	roff_t		off;		(* Offset of the lock in the region *)
	u_int32_t	ndx;		(* Index of the object referenced by
					 * this lock; used for locking. *)
	u_int32_t	gen;		(* Generation number of this lock. *)
	db_lockmode_t	mode;		(* mode of this lock. *)
};

(* Lock request structure. *)
struct __db_lockreq {
	db_lockop_t	 op;		(* Operation. *)
	db_lockmode_t	 mode;		(* Requested mode. *)
	db_timeout_t	 timeout;	(* Time to expire lock. *)
	DBT		*obj;		(* Object being locked. *)
	DB_LOCK		 lock;		(* Lock returned. *)
};

(*******************************************************
 * Logging.
 *******************************************************)
 	DB_LOGVERSION	12		(* Current log version. *)
 	DB_LOGOLDVER	8		(* Oldest log version supported. *)
 	DB_LOGMAGIC	$040988

(* Flag values for DB_ENV->log_archive(). *)
 	DB_ARCH_ABS	$001		(* Absolute pathnames. *)
 	DB_ARCH_DATA	$002		(* Data files. *)
 	DB_ARCH_LOG	$004		(* Log files. *)
 	DB_ARCH_REMOVE	$008	(* Remove log files. *)

(* Flag values for DB_ENV->log_put(). *)
 	DB_FLUSH		$001	(* Flush data to disk (public). *)
 	DB_LOG_CHKPNT		$002	(* Flush supports a checkpoint *)
 	DB_LOG_COMMIT		$004	(* Flush supports a commit *)
 	DB_LOG_NOCOPY		$008	(* Don't copy data *)
 	DB_LOG_NOT_DURABLE	$010	(* Do not log; keep in memory *)
 	DB_LOG_WRNOSYNC		$020	(* Write, don't sync log_put *)

(*
 * A DB_LSN has two parts, a fileid which identifies a specific file, and an
 * offset within that file.  The fileid is an unsigned 4-byte quantity that
 * uniquely identifies a file within the log directory -- currently a simple
 * counter inside the log.  The offset is also an unsigned 4-byte value.  The
 * log manager guarantees the offset is never more than 4 bytes by switching
 * to a new log file before the maximum length imposed by an unsigned 4-byte
 * offset is reached.
 *)
struct __db_lsn {
	u_int32_t	file;		(* File ID. *)
	u_int32_t	offset;		(* File offset. *)
};

(*
 * Application-specified log record types start at DB_user_BEGIN, and must not
 * equal or exceed DB_debug_FLAG.
 *
 * DB_debug_FLAG is the high-bit of the u_int32_t that specifies a log record
 * type.  If the flag is set, it's a log record that was logged for debugging
 * purposes only, even if it reflects a database change -- the change was part
 * of a non-durable transaction.
 *)
 	DB_user_BEGIN		10000
 	DB_debug_FLAG		$80000000

(*
 * DB_LOGC --
 *	Log cursor.
 *)
struct __db_log_cursor {
	DB_ENV	 *dbenv;		(* Enclosing dbenv. *)

	DB_FH	 *c_fhp;		(* File handle. *)
	DB_LSN	  c_lsn;		(* Cursor: LSN *)
	u_int32_t c_len;		(* Cursor: record length *)
	u_int32_t c_prev;		(* Cursor: previous record's offset *)

	DBT	  c_dbt;		(* Return DBT. *)
	DB_LSN    p_lsn;		(* Persist LSN. *)
	u_int32_t p_version;		(* Persist version. *)

	u_int8_t *bp;			(* Allocated read buffer. *)
	u_int32_t bp_size;		(* Read buffer length in bytes. *)
	u_int32_t bp_rlen;		(* Read buffer valid data length. *)
	DB_LSN	  bp_lsn;		(* Read buffer first byte LSN. *)

	u_int32_t bp_maxrec;		(* Max record length in the log file. *)

	(* DB_LOGC PUBLIC HANDLE LIST BEGIN *)
	int (*close) __P((DB_LOGC *, u_int32_t));
	int (*get) __P((DB_LOGC *, DB_LSN *, DBT *, u_int32_t));
	int (*version) __P((DB_LOGC *, u_int32_t *, u_int32_t));
	(* DB_LOGC PUBLIC HANDLE LIST END *)

 	DB_LOG_DISK		$01	(* Log record came from disk. *)
 	DB_LOG_LOCKED		$02	(* Log region already locked *)
 	DB_LOG_SILENT_ERR	$04	(* Turn-off error messages. *)
	u_int32_t flags;
};

(* Log statistics structure. *)
struct __db_log_stat {
	u_int32_t st_magic;		(* Log file magic number. *)
	u_int32_t st_version;		(* Log file version number. *)
	int	  st_mode;		(* Log file permissions mode. *)
	u_int32_t st_lg_bsize;		(* Log buffer size. *)
	u_int32_t st_lg_size;		(* Log file size. *)
	u_int32_t st_record;		(* Records entered into the log. *)
	u_int32_t st_w_bytes;		(* Bytes to log. *)
	u_int32_t st_w_mbytes;		(* Megabytes to log. *)
	u_int32_t st_wc_bytes;		(* Bytes to log since checkpoint. *)
	u_int32_t st_wc_mbytes;		(* Megabytes to log since checkpoint. *)
	u_int32_t st_wcount;		(* Total I/O writes to the log. *)
	u_int32_t st_wcount_fill;	(* Overflow writes to the log. *)
	u_int32_t st_rcount;		(* Total I/O reads from the log. *)
	u_int32_t st_scount;		(* Total syncs to the log. *)
	u_int32_t st_region_wait;	(* Region lock granted after wait. *)
	u_int32_t st_region_nowait;	(* Region lock granted without wait. *)
	u_int32_t st_cur_file;		(* Current log file number. *)
	u_int32_t st_cur_offset;	(* Current log file offset. *)
	u_int32_t st_disk_file;		(* Known on disk log file number. *)
	u_int32_t st_disk_offset;	(* Known on disk log file offset. *)
	roff_t	  st_regsize;		(* Region size. *)
	u_int32_t st_maxcommitperflush;	(* Max number of commits in a flush. *)
	u_int32_t st_mincommitperflush;	(* Min number of commits in a flush. *)
};

(*
 * We need to record the first log record of a transaction.  For user
 * defined logging this macro returns the place to put that information,
 * if it is need in rlsnp, otherwise it leaves it unchanged.  We also
 * need to track the last record of the transaction, this returns the
 * place to put that info.
 *)
 	DB_SET_TXN_LSNP(txn, blsnp, llsnp)		\
	((txn)->set_txn_lsnp(txn, blsnp, llsnp))

(*******************************************************
 * Shared buffer cache (mpool).
 *******************************************************)
(* Flag values for DB_MPOOLFILE->get. *)
 	DB_MPOOL_CREATE		$001	(* Create a page. *)
 	DB_MPOOL_DIRTY		$002	(* Get page for an update. *)
 	DB_MPOOL_EDIT		$004	(* Modify without copying. *)
 	DB_MPOOL_FREE		$008	(* Free page if present. *)
 	DB_MPOOL_LAST		$010	(* Return the last page. *)
 	DB_MPOOL_NEW		$020	(* Create a new page. *)

(* Flag values for DB_MPOOLFILE->put, DB_MPOOLFILE->set. *)
 	DB_MPOOL_DISCARD	$001	(* Don't cache the page. *)

(* Flags values for DB_MPOOLFILE->set_flags. *)
 	DB_MPOOL_NOFILE		$001	(* Never open a backing file. *)
 	DB_MPOOL_UNLINK		$002	(* Unlink the file on last close. *)

(* Priority values for DB_MPOOLFILE->set_priority. *)
type enum {
	DB_PRIORITY_VERY_LOW=1,
	DB_PRIORITY_LOW=2,
	DB_PRIORITY_DEFAULT=3,
	DB_PRIORITY_HIGH=4,
	DB_PRIORITY_VERY_HIGH=5
} DB_CACHE_PRIORITY;

(* Per-process DB_MPOOLFILE information. *)
struct __db_mpoolfile {
	DB_FH	  *fhp;			(* Underlying file handle. *)

	(*
	 * !!!
	 * The ref, pinref and q fields are protected by the region lock.
	 *)
	u_int32_t  ref;			(* Reference count. *)

	u_int32_t pinref;		(* Pinned block reference count. *)

	(*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(__db_mpoolfile) q;
	 *)
	struct {
		struct __db_mpoolfile *tqe_next;
		struct __db_mpoolfile **tqe_prev;
	} q;				(* Linked list of DB_MPOOLFILE's. *)

	(*
	 * !!!
	 * The rest of the fields (with the exception of the MP_FLUSH flag)
	 * are not thread-protected, even when they may be modified at any
	 * time by the application.  The reason is the DB_MPOOLFILE handle
	 * is single-threaded from the viewpoint of the application, and so
	 * the only fields needing to be thread-protected are those accessed
	 * by checkpoint or sync threads when using DB_MPOOLFILE structures
	 * to flush buffers from the cache.
	 *)
	DB_ENV	       *dbenv;		(* Overlying DB_ENV. *)
	MPOOLFILE      *mfp;		(* Underlying MPOOLFILE. *)

	u_int32_t	clear_len;	(* Cleared length on created pages. *)
	u_int8_t			(* Unique file ID. *)
			fileid[DB_FILE_ID_LEN];
	int		ftype;		(* File type. *)
	int32_t		lsn_offset;	(* LSN offset in page. *)
	u_int32_t	gbytes, bytes;	(* Maximum file size. *)
	DBT	       *pgcookie;	(* Byte-string passed to pgin/pgout. *)
	int32_t		priority;	(* Cache priority. *)

	void	       *addr;		(* Address of mmap'd region. *)
	size_t		len;		(* Length of mmap'd region. *)

	u_int32_t	config_flags;	(* Flags to DB_MPOOLFILE->set_flags. *)

	(* DB_MPOOLFILE PUBLIC HANDLE LIST BEGIN *)
	int (*close) __P((DB_MPOOLFILE *, u_int32_t));
	int (*get)
	    __P((DB_MPOOLFILE *, db_pgno_t *, DB_TXN *, u_int32_t, Pointer ));
	int (*open) __P((DB_MPOOLFILE *, const char *, u_int32_t, int, size_t));
	int (*put) __P((DB_MPOOLFILE *, Pointer , u_int32_t));
	int (*set) __P((DB_MPOOLFILE *, Pointer , u_int32_t));
	int (*get_clear_len) __P((DB_MPOOLFILE *, u_int32_t *));
	int (*set_clear_len) __P((DB_MPOOLFILE *, u_int32_t));
	int (*get_fileid) __P((DB_MPOOLFILE *, u_int8_t *));
	int (*set_fileid) __P((DB_MPOOLFILE *, u_int8_t *));
	int (*get_flags) __P((DB_MPOOLFILE *, u_int32_t *));
	int (*set_flags) __P((DB_MPOOLFILE *, u_int32_t, int));
	int (*get_ftype) __P((DB_MPOOLFILE *, int *));
	int (*set_ftype) __P((DB_MPOOLFILE *, int));
	int (*get_lsn_offset) __P((DB_MPOOLFILE *, int32_t *));
	int (*set_lsn_offset) __P((DB_MPOOLFILE *, int32_t));
	int (*get_maxsize) __P((DB_MPOOLFILE *, u_int32_t *, u_int32_t *));
	int (*set_maxsize) __P((DB_MPOOLFILE *, u_int32_t, u_int32_t));
	int (*get_pgcookie) __P((DB_MPOOLFILE *, DBT *));
	int (*set_pgcookie) __P((DB_MPOOLFILE *, DBT *));
	int (*get_priority) __P((DB_MPOOLFILE *, DB_CACHE_PRIORITY *));
	int (*set_priority) __P((DB_MPOOLFILE *, DB_CACHE_PRIORITY));
	int (*sync) __P((DB_MPOOLFILE *));
	(* DB_MPOOLFILE PUBLIC HANDLE LIST END *)

	(*
	 * MP_FILEID_SET, MP_OPEN_CALLED and MP_READONLY do not need to be
	 * thread protected because they are initialized before the file is
	 * linked onto the per-process lists, and never modified.
	 *
	 * MP_FLUSH is thread protected because it is potentially read/set by
	 * multiple threads of control.
	 *)
 	MP_FILEID_SET	$001		(* Application supplied a file ID. *)
 	MP_FLUSH	$002		(* Was opened to flush a buffer. *)
 	MP_MULTIVERSION	$004		(* Opened for multiversion access. *)
 	MP_OPEN_CALLED	$008		(* File opened. *)
 	MP_READONLY	$010		(* File is readonly. *)
	u_int32_t  flags;
};

(* Mpool statistics structure. *)
struct __db_mpool_stat {
	u_int32_t st_gbytes;		(* Total cache size: GB. *)
	u_int32_t st_bytes;		(* Total cache size: B. *)
	u_int32_t st_ncache;		(* Number of caches. *)
	roff_t	  st_regsize;		(* Region size. *)
	size_t	  st_mmapsize;		(* Maximum file size for mmap. *)
	int	  st_maxopenfd;		(* Maximum number of open fd's. *)
	int	  st_maxwrite;		(* Maximum buffers to write. *)
	int	  st_maxwrite_sleep;	(* Sleep after writing max buffers. *)
	u_int32_t st_map;		(* Pages from mapped files. *)
	u_int32_t st_cache_hit;		(* Pages found in the cache. *)
	u_int32_t st_cache_miss;	(* Pages not found in the cache. *)
	u_int32_t st_page_create;	(* Pages created in the cache. *)
	u_int32_t st_page_in;		(* Pages read in. *)
	u_int32_t st_page_out;		(* Pages written out. *)
	u_int32_t st_ro_evict;		(* Clean pages forced from the cache. *)
	u_int32_t st_rw_evict;		(* Dirty pages forced from the cache. *)
	u_int32_t st_page_trickle;	(* Pages written by memp_trickle. *)
	u_int32_t st_pages;		(* Total number of pages. *)
	u_int32_t st_page_clean;	(* Clean pages. *)
	u_int32_t st_page_dirty;	(* Dirty pages. *)
	u_int32_t st_hash_buckets;	(* Number of hash buckets. *)
	u_int32_t st_hash_searches;	(* Total hash chain searches. *)
	u_int32_t st_hash_longest;	(* Longest hash chain searched. *)
	u_int32_t st_hash_examined;	(* Total hash entries searched. *)
	u_int32_t st_hash_nowait;	(* Hash lock granted with nowait. *)
	u_int32_t st_hash_wait;		(* Hash lock granted after wait. *)
	u_int32_t st_hash_max_nowait;	(* Max hash lock granted with nowait. *)
	u_int32_t st_hash_max_wait;	(* Max hash lock granted after wait. *)
	u_int32_t st_region_nowait;	(* Region lock granted with nowait. *)
	u_int32_t st_region_wait;	(* Region lock granted after wait. *)
	u_int32_t st_mvcc_frozen;		(* Buffers frozen. *)
	u_int32_t st_mvcc_thawed;		(* Buffers thawed. *)
	u_int32_t st_mvcc_freed;		(* Frozen buffers freed. *)
	u_int32_t st_alloc;		(* Number of page allocations. *)
	u_int32_t st_alloc_buckets;	(* Buckets checked during allocation. *)
	u_int32_t st_alloc_max_buckets;	(* Max checked during allocation. *)
	u_int32_t st_alloc_pages;	(* Pages checked during allocation. *)
	u_int32_t st_alloc_max_pages;	(* Max checked during allocation. *)
	u_int32_t st_io_wait;		(* Thread waited on buffer I/O. *)
};

(* Mpool file statistics structure. *)
struct __db_mpool_fstat {
	char *file_name;		(* File name. *)
	u_int32_t st_pagesize;		(* Page size. *)
	u_int32_t st_map;		(* Pages from mapped files. *)
	u_int32_t st_cache_hit;		(* Pages found in the cache. *)
	u_int32_t st_cache_miss;	(* Pages not found in the cache. *)
	u_int32_t st_page_create;	(* Pages created in the cache. *)
	u_int32_t st_page_in;		(* Pages read in. *)
	u_int32_t st_page_out;		(* Pages written out. *)
};

(*******************************************************
 * Transactions and recovery.
 *******************************************************)
 	DB_TXNVERSION	1

type enum {
	DB_TXN_ABORT=0,			(* Public. *)
	DB_TXN_APPLY=1,			(* Public. *)
	DB_TXN_BACKWARD_ALLOC=2,	(* Internal. *)
	DB_TXN_BACKWARD_ROLL=3,		(* Public. *)
	DB_TXN_FORWARD_ROLL=4,		(* Public. *)
	DB_TXN_OPENFILES=5,		(* Internal. *)
	DB_TXN_POPENFILES=6,		(* Internal. *)
	DB_TXN_PRINT=7			(* Public. *)
} db_recops;

(*
 * BACKWARD_ALLOC is used during the forward pass to pick up any aborted
 * allocations for files that were created during the forward pass.
 * The main difference between _ALLOC and _ROLL is that the entry for
 * the file not exist during the rollforward pass.
 *)
 	DB_UNDO(op)	((op) == DB_TXN_ABORT ||			\
		(op) == DB_TXN_BACKWARD_ROLL || (op) == DB_TXN_BACKWARD_ALLOC)
 	DB_REDO(op)	((op) == DB_TXN_FORWARD_ROLL || (op) == DB_TXN_APPLY)

struct __db_txn {
	DB_TXNMGR	*mgrp;		(* Pointer to transaction manager. *)
	DB_TXN		*parent;	(* Pointer to transaction's parent. *)

	u_int32_t	txnid;		(* Unique transaction id. *)
	char		*name;		(* Transaction name *)

	db_threadid_t	tid;		(* Thread id for use in MT XA. *)
	void		*td;		(* Detail structure within region. *)
	db_timeout_t	lock_timeout;	(* Timeout for locks for this txn. *)
	db_timeout_t	expire;		(* Time transaction expires. *)
	void		*txn_list;	(* Undo information for parent. *)

	(*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(__db_txn) links;
	 * TAILQ_ENTRY(__db_txn) xalinks;
	 *)
	struct {
		struct __db_txn *tqe_next;
		struct __db_txn **tqe_prev;
	} links;			(* Links transactions off manager. *)
	struct {
		struct __db_txn *tqe_next;
		struct __db_txn **tqe_prev;
	} xalinks;			(* Links active XA transactions. *)

	(*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_HEAD(__kids, __db_txn) kids;
	 *)
	struct __kids {
		struct __db_txn *tqh_first;
		struct __db_txn **tqh_last;
	} kids;

	(*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_HEAD(__events, __txn_event) events;
	 *)
	struct {
		struct __txn_event *tqh_first;
		struct __txn_event **tqh_last;
	} events;

	(*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * STAILQ_HEAD(__logrec, __txn_logrec) logs;
	 *)
	struct {
		struct __txn_logrec *stqh_first;
		struct __txn_logrec **stqh_last;
	} logs;				(* Links deferred events. *)

	(*
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(__db_txn) klinks;
	 *)
	struct {
		struct __db_txn *tqe_next;
		struct __db_txn **tqe_prev;
	} klinks;

	void	*api_internal;		(* C++ API private. *)
	void	*xml_internal;		(* XML API private. *)

	u_int32_t	cursors;	(* Number of cursors open for txn *)

	(* DB_TXN PUBLIC HANDLE LIST BEGIN *)
	int	  (*abort) __P((DB_TXN *));
	int	  (*commit) __P((DB_TXN *, u_int32_t));
	int	  (*discard) __P((DB_TXN *, u_int32_t));
	int	  (*get_name) __P((DB_TXN *, const char **));
	u_int32_t (*id) __P((DB_TXN *));
	int	  (*prepare) __P((DB_TXN *, u_int8_t *));
	int	  (*set_name) __P((DB_TXN *, const char *));
	int	  (*set_timeout) __P((DB_TXN *, db_timeout_t, u_int32_t));
	(* DB_TXN PUBLIC HANDLE LIST END *)

	(* DB_TXN PRIVATE HANDLE LIST BEGIN *)
	void	  (*set_txn_lsnp) __P((DB_TXN *txn, DB_LSN **, DB_LSN **));
	(* DB_TXN PRIVATE HANDLE LIST END *)

 	TXN_CHILDCOMMIT		$0001	(* Txn has committed. *)
 	TXN_CDSGROUP		$0002	(* CDS group handle. *)
 	TXN_COMPENSATE		$0004	(* Compensating transaction. *)
 	TXN_DEADLOCK		$0008	(* Txn has deadlocked. *)
 	TXN_LOCKTIMEOUT		$0010	(* Txn has a lock timeout. *)
 	TXN_MALLOC		$0020	(* Structure allocated by TXN system. *)
 	TXN_NOSYNC		$0040	(* Do not sync on prepare and commit. *)
 	TXN_NOWAIT		$0080	(* Do not wait on locks. *)
 	TXN_PRIVATE		$0100	(* Txn owned by cursor.. *)
 	TXN_READ_COMMITTED	$0200	(* Txn has degree 2 isolation. *)
 	TXN_READ_UNCOMMITTED	$0400	(* Txn has degree 1 isolation. *)
 	TXN_RESTORED		$0800	(* Txn has been restored. *)
 	TXN_SNAPSHOT		$1000	(* Snapshot Isolation. *)
 	TXN_SYNC		$2000	(* Write and sync on prepare/commit. *)
 	TXN_WRITE_NOSYNC	$4000	(* Write only on prepare/commit. *)
	u_int32_t	flags;
};

 	TXN_SYNC_FLAGS (TXN_SYNC | TXN_NOSYNC | TXN_WRITE_NOSYNC)

(*
 * Structure used for two phase commit interface.  Berkeley DB support for two
 * phase commit is compatible with the X/Open XA interface.
 *
 * The XA   XIDDATASIZE defines the size of a global transaction ID.  We
 * have our own version here (for name space reasons) which must have the same
 * value.
 *)
 	DB_XIDDATASIZE	128
struct __db_preplist {
	DB_TXN	*txn;
	u_int8_t gid[DB_XIDDATASIZE];
};

(* Transaction statistics structure. *)
struct __db_txn_active {
	u_int32_t txnid;		(* Transaction ID *)
	u_int32_t parentid;		(* Transaction ID of parent *)
	pid_t     pid;			(* Process owning txn ID *)
	db_threadid_t tid;		(* Thread owning txn ID *)

	DB_LSN	  lsn;			(* LSN when transaction began *)

	DB_LSN	  read_lsn;		(* Read LSN for MVCC *)
	u_int32_t mvcc_ref;		(* MVCC reference count *)

 	TXN_ABORTED		1
 	TXN_COMMITTED		2
 	TXN_PREPARED		3
 	TXN_RUNNING		4
	u_int32_t status;		(* Status of the transaction *)

 	TXN_XA_ABORTED		1
 	TXN_XA_DEADLOCKED	2
 	TXN_XA_ENDED		3
 	TXN_XA_PREPARED		4
 	TXN_XA_STARTED		5
 	TXN_XA_SUSPENDED	6
	u_int32_t xa_status;		(* XA status *)

	u_int8_t  xid[DB_XIDDATASIZE];	(* Global transaction ID *)
	char	  name[51];		(* 50 bytes of name, nul termination *)
};

struct __db_txn_stat {
	DB_LSN	  st_last_ckp;		(* lsn of the last checkpoint *)
	time_t	  st_time_ckp;		(* time of last checkpoint *)
	u_int32_t st_last_txnid;	(* last transaction id given out *)
	u_int32_t st_maxtxns;		(* maximum txns possible *)
	u_int32_t st_naborts;		(* number of aborted transactions *)
	u_int32_t st_nbegins;		(* number of begun transactions *)
	u_int32_t st_ncommits;		(* number of committed transactions *)
	u_int32_t st_nactive;		(* number of active transactions *)
	u_int32_t st_nsnapshot;		(* number of snapshot transactions *)
	u_int32_t st_nrestores;		(* number of restored transactions
					   after recovery. *)
	u_int32_t st_maxnactive;	(* maximum active transactions *)
	u_int32_t st_maxnsnapshot;	(* maximum snapshot transactions *)
	DB_TXN_ACTIVE *st_txnarray;	(* array of active transactions *)
	u_int32_t st_region_wait;	(* Region lock granted after wait. *)
	u_int32_t st_region_nowait;	(* Region lock granted without wait. *)
	roff_t	  st_regsize;		(* Region size. *)
};

(*******************************************************
 * Replication.
 *******************************************************)
(* Special, out-of-band environment IDs. *)
 	DB_EID_BROADCAST	-1
 	DB_EID_INVALID		-2

(* rep_config flag values. *)
 	DB_REP_CONF_BULK	$0001	(* Bulk transfer. *)
 	DB_REP_CONF_DELAYCLIENT	$0002	(* Delay client synchronization. *)
 	DB_REP_CONF_NOAUTOINIT	$0004	(* No automatic client init. *)
 	DB_REP_CONF_NOWAIT	$0008	(* Don't wait, return error. *)

(*
 * Operation code values for rep_start and/or repmgr_start.  Just one of the
 * following values should be passed in the flags parameter.  (If we ever need
 * additional, independent bit flags for these methods, we can start allocating
 * them from the high-order byte of the flags word, as we currently do elsewhere
 * for DB_AFTER through DB_WRITELOCK and DB_AUTO_COMMIT, etc.)
 *)
 	DB_REP_CLIENT			1
 	DB_REP_ELECTION			2
 	DB_REP_FULL_ELECTION		3
 	DB_REP_MASTER			4

(* Acknowledgement policies. *)
 	DB_REPMGR_ACKS_ALL		1
 	DB_REPMGR_ACKS_ALL_PEERS	2
 	DB_REPMGR_ACKS_NONE		3
 	DB_REPMGR_ACKS_ONE		4
 	DB_REPMGR_ACKS_ONE_PEER		5
 	DB_REPMGR_ACKS_QUORUM		6

(* Replication Framework timeout configuration values. *)
 	DB_REP_ACK_TIMEOUT	1
 	DB_REP_ELECTION_TIMEOUT 2
 	DB_REP_ELECTION_RETRY	3
 	DB_REP_CONNECTION_RETRY 4

(* Event notification types. *)
 	DB_EVENT_NO_SUCH_EVENT		0 (* out-of-band sentinel value *)
 	DB_EVENT_PANIC			1
 	DB_EVENT_REP_CLIENT		2
 	DB_EVENT_REP_MASTER		3
 	DB_EVENT_REP_NEWMASTER		4
 	DB_EVENT_REP_STARTUPDONE	5
 	DB_EVENT_WRITE_FAILED		6

(* Flag value for repmgr_add_remote_site. *)
 	DB_REPMGR_PEER          $01

(* Replication Manager site status. *)
struct __db_repmgr_site {
        int eid;
        char *host;
        u_int port;

 	DB_REPMGR_CONNECTED	$01
 	DB_REPMGR_DISCONNECTED	$02
        u_int32_t status;
};

(* Replication statistics. *)
struct __db_rep_stat {
	(* !!!
	 * Many replication statistics fields cannot be protected by a mutex
	 * without an unacceptable performance penalty, since most message
	 * processing is done without the need to hold a region-wide lock.
	 * Fields whose comments end with a '+' may be updated without holding
	 * the replication or log mutexes (as appropriate), and thus may be
	 * off somewhat (or, on unreasonable architectures under unlucky
	 * circumstances, garbaged).
	 *)
	u_int32_t st_status;		(* Current replication status. *)
	DB_LSN st_next_lsn;		(* Next LSN to use or expect. *)
	DB_LSN st_waiting_lsn;		(* LSN we're awaiting, if any. *)
	db_pgno_t st_next_pg;		(* Next pg we expect. *)
	db_pgno_t st_waiting_pg;	(* pg we're awaiting, if any. *)

	u_int32_t st_dupmasters;	(* # of times a duplicate master
					   condition was detected.+ *)
	int st_env_id;			(* Current environment ID. *)
	int st_env_priority;		(* Current environment priority. *)
	u_int32_t st_bulk_fills;	(* Bulk buffer fills. *)
	u_int32_t st_bulk_overflows;	(* Bulk buffer overflows. *)
	u_int32_t st_bulk_records;	(* Bulk records stored. *)
	u_int32_t st_bulk_transfers;	(* Transfers of bulk buffers. *)
	u_int32_t st_client_rerequests;	(* Number of forced rerequests. *)
	u_int32_t st_client_svc_req;	(* Number of client service requests
					   received by this client. *)
	u_int32_t st_client_svc_miss;	(* Number of client service requests
					   missing on this client. *)
	u_int32_t st_gen;		(* Current generation number. *)
	u_int32_t st_egen;		(* Current election gen number. *)
	u_int32_t st_log_duplicated;	(* Log records received multiply.+ *)
	u_int32_t st_log_queued;	(* Log records currently queued.+ *)
	u_int32_t st_log_queued_max;	(* Max. log records queued at once.+ *)
	u_int32_t st_log_queued_total;	(* Total # of log recs. ever queued.+ *)
	u_int32_t st_log_records;	(* Log records received and put.+ *)
	u_int32_t st_log_requested;	(* Log recs. missed and requested.+ *)
	int st_master;			(* Env. ID of the current master. *)
	u_int32_t st_master_changes;	(* # of times we've switched masters. *)
	u_int32_t st_msgs_badgen;	(* Messages with a bad generation #.+ *)
	u_int32_t st_msgs_processed;	(* Messages received and processed.+ *)
	u_int32_t st_msgs_recover;	(* Messages ignored because this site
					   was a client in recovery.+ *)
	u_int32_t st_msgs_send_failures;(* # of failed message sends.+ *)
	u_int32_t st_msgs_sent;		(* # of successful message sends.+ *)
	u_int32_t st_newsites;		(* # of NEWSITE msgs. received.+ *)
	int st_nsites;			(* Current number of sites we will
					   assume during elections. *)
	u_int32_t st_nthrottles;	(* # of times we were throttled. *)
	u_int32_t st_outdated;		(* # of times we detected and returned
					   an OUTDATED condition.+ *)
	u_int32_t st_pg_duplicated;	(* Pages received multiply.+ *)
	u_int32_t st_pg_records;	(* Pages received and stored.+ *)
	u_int32_t st_pg_requested;	(* Pages missed and requested.+ *)
	u_int32_t st_startup_complete;	(* Site completed client sync-up. *)
	u_int32_t st_txns_applied;	(* # of transactions applied.+ *)

	(* Elections generally. *)
	u_int32_t st_elections;		(* # of elections held.+ *)
	u_int32_t st_elections_won;	(* # of elections won by this site.+ *)

	(* Statistics about an in-progress election. *)
	int st_election_cur_winner;	(* Current front-runner. *)
	u_int32_t st_election_gen;	(* Election generation number. *)
	DB_LSN st_election_lsn;		(* Max. LSN of current winner. *)
	int st_election_nsites;		(* # of 'registered voters'. *)
	int st_election_nvotes;		(* # of 'registered voters' needed. *)
	int st_election_priority;	(* Current election priority. *)
	int st_election_status;		(* Current election status. *)
	u_int32_t st_election_tiebreaker;(* Election tiebreaker value. *)
	int st_election_votes;		(* Votes received in this round. *)
	u_int32_t st_election_sec;	(* Last election time seconds. *)
	u_int32_t st_election_usec;	(* Last election time useconds. *)
};

(*******************************************************
 * Sequences.
 *******************************************************)
(*
 * The storage record for a sequence.
 *)
struct __db_seq_record {
	u_int32_t	seq_version;	(* Version size/number. *)
 	DB_SEQ_DEC		$00000001	(* Decrement sequence. *)
 	DB_SEQ_INC		$00000002	(* Increment sequence. *)
 	DB_SEQ_RANGE_SET	$00000004	(* Range set (internal). *)
 	DB_SEQ_WRAP		$00000008	(* Wrap sequence at min/max. *)
 	DB_SEQ_WRAPPED		$00000010	(* Just wrapped (internal). *)
	u_int32_t	flags;		(* Flags. *)
	db_seq_t	seq_value;	(* Current value. *)
	db_seq_t	seq_max;	(* Max permitted. *)
	db_seq_t	seq_min;	(* Min permitted. *)
};

(*
 * Handle for a sequence object.
 *)
struct __db_sequence {
	DB		*seq_dbp;	(* DB handle for this sequence. *)
	db_mutex_t	mtx_seq;	(* Mutex if sequence is threaded. *)
	DB_SEQ_RECORD	*seq_rp;	(* Pointer to current data. *)
	DB_SEQ_RECORD	seq_record;	(* Data from DB_SEQUENCE. *)
	int32_t		seq_cache_size; (* Number of values cached. *)
	db_seq_t	seq_last_value;	(* Last value cached. *)
	DBT		seq_key;	(* DBT pointing to sequence key. *)
	DBT		seq_data;	(* DBT pointing to seq_record. *)

	(* API-private structure: used by C++ and Java. *)
	void		*api_internal;

	(* DB_SEQUENCE PUBLIC HANDLE LIST BEGIN *)
	int		(*close) __P((DB_SEQUENCE *, u_int32_t));
	int		(*get) __P((DB_SEQUENCE *,
			      DB_TXN *, int32_t, db_seq_t *, u_int32_t));
	int		(*get_cachesize) __P((DB_SEQUENCE *, int32_t *));
	int		(*get_db) __P((DB_SEQUENCE *, DB **));
	int		(*get_flags) __P((DB_SEQUENCE *, u_int32_t *));
	int		(*get_key) __P((DB_SEQUENCE *, DBT *));
	int		(*get_range) __P((DB_SEQUENCE *,
			     db_seq_t *, db_seq_t *));
	int		(*initial_value) __P((DB_SEQUENCE *, db_seq_t));
	int		(*open) __P((DB_SEQUENCE *,
			    DB_TXN *, DBT *, u_int32_t));
	int		(*remove) __P((DB_SEQUENCE *, DB_TXN *, u_int32_t));
	int		(*set_cachesize) __P((DB_SEQUENCE *, int32_t));
	int		(*set_flags) __P((DB_SEQUENCE *, u_int32_t));
	int		(*set_range) __P((DB_SEQUENCE *, db_seq_t, db_seq_t));
	int		(*stat) __P((DB_SEQUENCE *,
			    DB_SEQUENCE_STAT **, u_int32_t));
	int		(*stat_print) __P((DB_SEQUENCE *, u_int32_t));
	(* DB_SEQUENCE PUBLIC HANDLE LIST END *)
};

struct __db_seq_stat {
	u_int32_t st_wait;		(* Sequence lock granted w/o wait. *)
	u_int32_t st_nowait;		(* Sequence lock granted after wait. *)
	db_seq_t  st_current;		(* Current value in db. *)
	db_seq_t  st_value;		(* Current cached value. *)
	db_seq_t  st_last_value;	(* Last cached value. *)
	db_seq_t  st_min;		(* Minimum value. *)
	db_seq_t  st_max;		(* Maximum value. *)
	int32_t   st_cache_size;	(* Cache size. *)
	u_int32_t st_flags;		(* Flag value. *)
};

(*******************************************************
 * Access methods.
 *******************************************************)
type enum {
	DB_BTREE=1,
	DB_HASH=2,
	DB_RECNO=3,
	DB_QUEUE=4,
	DB_UNKNOWN=5			(* Figure it out on open. *)
} DBTYPE;

 	DB_RENAMEMAGIC	$030800	(* File has been renamed. *)

 	DB_BTREEVERSION	9		(* Current btree version. *)
 	DB_BTREEOLDVER	8		(* Oldest btree version supported. *)
 	DB_BTREEMAGIC	$053162

 	DB_HASHVERSION	8		(* Current hash version. *)
 	DB_HASHOLDVER	7		(* Oldest hash version supported. *)
 	DB_HASHMAGIC	$061561

 	DB_QAMVERSION	4		(* Current queue version. *)
 	DB_QAMOLDVER	3		(* Oldest queue version supported. *)
 	DB_QAMMAGIC	$042253

 	DB_SEQUENCE_VERSION 2		(* Current sequence version. *)
 	DB_SEQUENCE_OLDVER  1		(* Oldest sequence version supported. *)

(*
 * DB access method and cursor operation values.  Each value is an operation
 * code to which additional bit flags are added.
 *)
 	DB_AFTER		 1	(* c_put() *)
 	DB_APPEND		 2	(* put() *)
 	DB_BEFORE		 3	(* c_put() *)
 	DB_CONSUME		 4	(* get() *)
 	DB_CONSUME_WAIT		 5	(* get() *)
 	DB_CURRENT		 6	(* c_get(), c_put(), DB_LOGC->get() *)
 	DB_FIRST		 7	(* c_get(), DB_LOGC->get() *)
 	DB_GET_BOTH		 8	(* get(), c_get() *)
 	DB_GET_BOTHC		 9	(* c_get() (internal) *)
 	DB_GET_BOTH_RANGE	10	(* get(), c_get() *)
 	DB_GET_RECNO		11	(* c_get() *)
 	DB_JOIN_ITEM		12	(* c_get(); do not do primary lookup *)
 	DB_KEYFIRST		13	(* c_put() *)
 	DB_KEYLAST		14	(* c_put() *)
 	DB_LAST			15	(* c_get(), DB_LOGC->get() *)
 	DB_NEXT			16	(* c_get(), DB_LOGC->get() *)
 	DB_NEXT_DUP		17	(* c_get() *)
 	DB_NEXT_NODUP		18	(* c_get() *)
 	DB_NODUPDATA		19	(* put(), c_put() *)
 	DB_NOOVERWRITE		20	(* put() *)
 	DB_NOSYNC		21	(* close() *)
 	DB_POSITION		22	(* c_dup() *)
 	DB_PREV			23	(* c_get(), DB_LOGC->get() *)
 	DB_PREV_NODUP		24	(* c_get(), DB_LOGC->get() *)
 	DB_SET			25	(* c_get(), DB_LOGC->get() *)
 	DB_SET_LOCK_TIMEOUT	26	(* set_timout() *)
 	DB_SET_RANGE		27	(* c_get() *)
 	DB_SET_RECNO		28	(* get(), c_get() *)
 	DB_SET_TXN_NOW		29	(* set_timout() (internal) *)
 	DB_SET_TXN_TIMEOUT	30	(* set_timout() *)
 	DB_UPDATE_SECONDARY	31	(* c_get(), c_del() (internal) *)
 	DB_WRITECURSOR		32	(* cursor() *)
 	DB_WRITELOCK		33	(* cursor() (internal) *)

(* This has to change when the max opcode hits 255. *)
 	DB_OPFLAGS_MASK	$000000ff	(* Mask for operations flags. *)

(*
 * Masks for flags that can be OR'd into DB access method and cursor
 * operation values.  Three top bits have already been taken:
 *
 * DB_AUTO_COMMIT	$02000000
 * DB_READ_COMMITTED	$04000000
 * DB_READ_UNCOMMITTED	$08000000
 *)
 	DB_MULTIPLE	$10000000	(* Return multiple data values. *)
 	DB_MULTIPLE_KEY	$20000000	(* Return multiple data/key pairs. *)
 	DB_RMW		$40000000	(* Acquire write lock immediately. *)

(*
 * DB (user visible) error return codes.
 *
 * !!!
 * We don't want our error returns to conflict with other packages where
 * possible, so pick a base error value that's hopefully not common.  We
 * document that we own the error name space from -30,800 to -30,999.
 *)
(* DB (public) error return codes. *)
 	DB_BUFFER_SMALL		(-30999)(* User memory too small for return. *)
 	DB_DONOTINDEX		(-30998)(* 'Null' return from 2ndary callbk. *)
 	DB_KEYEMPTY		(-30997)(* Key/data deleted or never created. *)
 	DB_KEYEXIST		(-30996)(* The key/data pair already exists. *)
 	DB_LOCK_DEADLOCK	(-30995)(* Deadlock. *)
 	DB_LOCK_NOTGRANTED	(-30994)(* Lock unavailable. *)
 	DB_LOG_BUFFER_FULL	(-30993)(* In-memory log buffer full. *)
 	DB_NOSERVER		(-30992)(* Server panic return. *)
 	DB_NOSERVER_HOME	(-30991)(* Bad home sent to server. *)
 	DB_NOSERVER_ID		(-30990)(* Bad ID sent to server. *)
 	DB_NOTFOUND		(-30989)(* Key/data pair not found (EOF). *)
 	DB_OLD_VERSION		(-30988)(* Out-of-date version. *)
 	DB_PAGE_NOTFOUND	(-30987)(* Requested page not found. *)
 	DB_REP_DUPMASTER	(-30986)(* There are two masters. *)
 	DB_REP_HANDLE_DEAD	(-30985)(* Rolled back a commit. *)
 	DB_REP_HOLDELECTION	(-30984)(* Time to hold an election. *)
 	DB_REP_IGNORE		(-30983)(* This msg should be ignored.*)
 	DB_REP_ISPERM		(-30982)(* Cached not written perm written.*)
 	DB_REP_JOIN_FAILURE	(-30981)(* Unable to join replication group. *)
 	DB_REP_LOCKOUT		(-30980)(* API/Replication lockout now. *)
 	DB_REP_NEWMASTER	(-30979)(* We have learned of a new master. *)
 	DB_REP_NEWSITE		(-30978)(* New site entered system. *)
 	DB_REP_NOTPERM		(-30977)(* Permanent log record not written. *)
 	DB_REP_UNAVAIL		(-30976)(* Site cannot currently be reached. *)
 	DB_RUNRECOVERY		(-30975)(* Panic return. *)
 	DB_SECONDARY_BAD	(-30974)(* Secondary index corrupt. *)
 	DB_VERIFY_BAD		(-30973)(* Verify failed; bad format. *)
 	DB_VERSION_MISMATCH	(-30972)(* Environment version mismatch. *)

(* DB (private) error return codes. *)
 	DB_ALREADY_ABORTED	(-30899)
 	DB_DELETED		(-30898)(* Recovery file marked deleted. *)
 	DB_NEEDSPLIT		(-30897)(* Page needs to be split. *)
 	DB_REP_BULKOVF		(-30896)(* Rep bulk buffer overflow. *)
 	DB_REP_EGENCHG		(-30895)(* Egen changed while in election. *)
 	DB_REP_LOGREADY		(-30894)(* Rep log ready for recovery. *)
 	DB_REP_PAGEDONE		(-30893)(* This page was already done. *)
 	DB_SURPRISE_KID		(-30892)(* Child commit where parent
					   didn't know it was a parent. *)
 	DB_SWAPBYTES		(-30891)(* Database needs byte swapping. *)
 	DB_TIMEOUT		(-30890)(* Timed out waiting for election. *)
 	DB_TXN_CKP		(-30889)(* Encountered ckp record in log. *)
 	DB_VERIFY_FATAL		(-30888)(* DB->verify cannot proceed. *)

(* Database handle. *)
struct __db {
	(*******************************************************
	 * Public: owned by the application.
	 *******************************************************)
	u_int32_t pgsize;		(* Database logical page size. *)

					(* Callbacks. *)
	int (*db_append_recno) __P((DB *, DBT *, db_recno_t));
	void (*db_feedback) __P((DB *, int, int));
	int (*dup_compare) __P((DB *, const DBT *, const DBT *));

	void	*app_private;		(* Application-private handle. *)

	(*******************************************************
	 * Private: owned by DB.
	 *******************************************************)
	DB_ENV	*dbenv;			(* Backing environment. *)

	DBTYPE	 type;			(* DB access method type. *)

	DB_MPOOLFILE *mpf;		(* Backing buffer pool. *)

	db_mutex_t mutex;		(* Synchronization for free threading *)

	char *fname, *dname;		(* File/database passed to DB->open. *)
	u_int32_t open_flags;		(* Flags passed to DB->open. *)

	u_int8_t fileid[DB_FILE_ID_LEN];(* File's unique ID for locking. *)

	u_int32_t adj_fileid;		(* File's unique ID for curs. adj. *)

 	DB_LOGFILEID_INVALID	-1
	FNAME *log_filename;		(* File's naming info for logging. *)

	db_pgno_t meta_pgno;		(* Meta page number *)
	u_int32_t lid;			(* Locker id for handle locking. *)
	u_int32_t cur_lid;		(* Current handle lock holder. *)
	u_int32_t associate_lid;	(* Locker id for DB->associate call. *)
	DB_LOCK	 handle_lock;		(* Lock held on this handle. *)

	u_int	 cl_id;			(* RPC: remote client id. *)

	time_t	 timestamp;		(* Handle timestamp for replication. *)
	u_int32_t fid_gen;		(* Rep generation number for fids. *)

	(*
	 * Returned data memory for DB->get() and friends.
	 *)
	DBT	 my_rskey;		(* Secondary key. *)
	DBT	 my_rkey;		(* [Primary] key. *)
	DBT	 my_rdata;		(* Data. *)

	(*
	 * !!!
	 * Some applications use DB but implement their own locking outside of
	 * DB.  If they're using fcntl(2) locking on the underlying database
	 * file, and we open and close a file descriptor for that file, we will
	 * discard their locks.  The DB_FCNTL_LOCKING flag to DB->open is an
	 * undocumented interface to support this usage which leaves any file
	 * descriptors we open until DB->close.  This will only work with the
	 * DB->open interface and simple caches, e.g., creating a transaction
	 * thread may open/close file descriptors this flag doesn't protect.
	 * Locking with fcntl(2) on a file that you don't own is a very, very
	 * unsafe thing to do.  'Nuff said.
	 *)
	DB_FH	*saved_open_fhp;	(* Saved file handle. *)

	(*
	 * Linked list of DBP's, linked from the DB_ENV, used to keep track
	 * of all open db handles for cursor adjustment.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(__db) dblistlinks;
	 *)
	struct {
		struct __db *tqe_next;
		struct __db **tqe_prev;
	} dblistlinks;

	(*
	 * Cursor queues.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_HEAD(__cq_fq, __dbc) free_queue;
	 * TAILQ_HEAD(__cq_aq, __dbc) active_queue;
	 * TAILQ_HEAD(__cq_jq, __dbc) join_queue;
	 *)
	struct __cq_fq {
		struct __dbc *tqh_first;
		struct __dbc **tqh_last;
	} free_queue;
	struct __cq_aq {
		struct __dbc *tqh_first;
		struct __dbc **tqh_last;
	} active_queue;
	struct __cq_jq {
		struct __dbc *tqh_first;
		struct __dbc **tqh_last;
	} join_queue;

	(*
	 * Secondary index support.
	 *
	 * Linked list of secondary indices -- set in the primary.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * LIST_HEAD(s_secondaries, __db);
	 *)
	struct {
		struct __db *lh_first;
	} s_secondaries;

	(*
	 * List entries for secondaries, and reference count of how
	 * many threads are updating this secondary (see __db_c_put).
	 *
	 * !!!
	 * Note that these are synchronized by the primary's mutex, but
	 * filled in in the secondaries.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * LIST_ENTRY(__db) s_links;
	 *)
	struct {
		struct __db *le_next;
		struct __db **le_prev;
	} s_links;
	u_int32_t s_refcnt;

	(* Secondary callback and free functions -- set in the secondary. *)
	int	(*s_callback) __P((DB *, const DBT *, const DBT *, DBT *));

	(* Reference to primary -- set in the secondary. *)
	DB	*s_primary;

 	DB_ASSOC_IMMUTABLE_KEY    $00000001 (* Secondary key is immutable. *)

	(* Flags passed to associate -- set in the secondary. *)
	u_int32_t s_assoc_flags;

	(* API-private structure: used by DB 1.85, C++, Java, Perl and Tcl *)
	void	*api_internal;

	(* Subsystem-private structure. *)
	void	*bt_internal;		(* Btree/Recno access method. *)
	void	*h_internal;		(* Hash access method. *)
	void	*q_internal;		(* Queue access method. *)
	void	*xa_internal;		(* XA. *)

	(* DB PUBLIC HANDLE LIST BEGIN *)
	int  (*associate) __P((DB *, DB_TXN *, DB *,
		int (*)(DB *, const DBT *, const DBT *, DBT *), u_int32_t));
	int  (*close) __P((DB *, u_int32_t));
	int  (*compact) __P((DB *,
		DB_TXN *, DBT *, DBT *, DB_COMPACT *, u_int32_t, DBT *));
	int  (*cursor) __P((DB *, DB_TXN *, DBC **, u_int32_t));
	int  (*del) __P((DB *, DB_TXN *, DBT *, u_int32_t));
	void (*err) __P((DB *, int, const char *, ...));
	void (*errx) __P((DB *, const char *, ...));
	int  (*fd) __P((DB *, int *));
	int  (*get) __P((DB *, DB_TXN *, DBT *, DBT *, u_int32_t));
	int  (*get_bt_minkey) __P((DB *, u_int32_t *));
	int  (*get_byteswapped) __P((DB *, int *));
	int  (*get_cachesize) __P((DB *, u_int32_t *, u_int32_t *, int *));
	int  (*get_dbname) __P((DB *, const char **, const char **));
	int  (*get_encrypt_flags) __P((DB *, u_int32_t *));
	DB_ENV *(*get_env) __P((DB *));
	void (*get_errfile) __P((DB *, FILE **));
	void (*get_errpfx) __P((DB *, const char **));
	int  (*get_flags) __P((DB *, u_int32_t *));
	int  (*get_h_ffactor) __P((DB *, u_int32_t *));
	int  (*get_h_nelem) __P((DB *, u_int32_t *));
	int  (*get_lorder) __P((DB *, int *));
	DB_MPOOLFILE *(*get_mpf) __P((DB *));
	void (*get_msgfile) __P((DB *, FILE **));
	int  (*get_open_flags) __P((DB *, u_int32_t *));
	int  (*get_pagesize) __P((DB *, u_int32_t *));
	int  (*get_q_extentsize) __P((DB *, u_int32_t *));
	int  (*get_re_delim) __P((DB *, int *));
	int  (*get_re_len) __P((DB *, u_int32_t *));
	int  (*get_re_pad) __P((DB *, int *));
	int  (*get_re_source) __P((DB *, const char **));
	int  (*get_transactional) __P((DB *));
	int  (*get_type) __P((DB *, DBTYPE *));
	int  (*join) __P((DB *, DBC **, DBC **, u_int32_t));
	int  (*key_range)
		__P((DB *, DB_TXN *, DBT *, DB_KEY_RANGE *, u_int32_t));
	int  (*open) __P((DB *,
		DB_TXN *, const char *, const char *, DBTYPE, u_int32_t, int));
	int  (*pget) __P((DB *, DB_TXN *, DBT *, DBT *, DBT *, u_int32_t));
	int  (*put) __P((DB *, DB_TXN *, DBT *, DBT *, u_int32_t));
	int  (*remove) __P((DB *, const char *, const char *, u_int32_t));
	int  (*rename) __P((DB *,
		const char *, const char *, const char *, u_int32_t));
	int  (*set_alloc) __P((DB *, Pointer (*)(size_t),
		Pointer (*)(Pointer , size_t), void (*)(Pointer )));
	int  (*set_append_recno) __P((DB *, int (*)(DB *, DBT *, db_recno_t)));
	int  (*set_bt_compare)
		__P((DB *, int (*)(DB *, const DBT *, const DBT *)));
	int  (*set_bt_minkey) __P((DB *, u_int32_t));
	int  (*set_bt_prefix)
		__P((DB *, size_t (*)(DB *, const DBT *, const DBT *)));
	int  (*set_cachesize) __P((DB *, u_int32_t, u_int32_t, int));
	int  (*set_dup_compare)
		__P((DB *, int (*)(DB *, const DBT *, const DBT *)));
	int  (*set_encrypt) __P((DB *, const char *, u_int32_t));
	void (*set_errcall) __P((DB *,
		void (*)(const DB_ENV *, const char *, const char *)));
	void (*set_errfile) __P((DB *, FILE *));
	void (*set_errpfx) __P((DB *, const char *));
	int  (*set_feedback) __P((DB *, void (*)(DB *, int, int)));
	int  (*set_flags) __P((DB *, u_int32_t));
	int  (*set_h_ffactor) __P((DB *, u_int32_t));
	int  (*set_h_hash)
		__P((DB *, u_int32_t (*)(DB *, const Pointer , u_int32_t)));
	int  (*set_h_nelem) __P((DB *, u_int32_t));
	int  (*set_lorder) __P((DB *, int));
	void (*set_msgcall) __P((DB *, void (*)(const DB_ENV *, const char *)));
	void (*set_msgfile) __P((DB *, FILE *));
	int  (*set_pagesize) __P((DB *, u_int32_t));
	int  (*set_paniccall) __P((DB *, void (*)(DB_ENV *, int)));
	int  (*set_q_extentsize) __P((DB *, u_int32_t));
	int  (*set_re_delim) __P((DB *, int));
	int  (*set_re_len) __P((DB *, u_int32_t));
	int  (*set_re_pad) __P((DB *, int));
	int  (*set_re_source) __P((DB *, const char *));
	int  (*stat) __P((DB *, DB_TXN *, Pointer , u_int32_t));
	int  (*stat_print) __P((DB *, u_int32_t));
	int  (*sync) __P((DB *, u_int32_t));
	int  (*truncate) __P((DB *, DB_TXN *, u_int32_t *, u_int32_t));
	int  (*upgrade) __P((DB *, const char *, u_int32_t));
	int  (*verify)
		__P((DB *, const char *, const char *, FILE *, u_int32_t));
	(* DB PUBLIC HANDLE LIST END *)

	(* DB PRIVATE HANDLE LIST BEGIN *)
	int  (*dump) __P((DB *, const char *,
		int (*)(Pointer , const Pointer ), Pointer , int, int));
	int  (*db_am_remove) __P((DB *, DB_TXN *, const char *, const char *));
	int  (*db_am_rename) __P((DB *, DB_TXN *,
	    const char *, const char *, const char *));
	(* DB PRIVATE HANDLE LIST END *)

	(*
	 * Never called; these are a place to save function pointers
	 * so that we can undo an associate.
	 *)
	int  (*stored_get) __P((DB *, DB_TXN *, DBT *, DBT *, u_int32_t));
	int  (*stored_close) __P((DB *, u_int32_t));

 	DB_OK_BTREE	$01
 	DB_OK_HASH	$02
 	DB_OK_QUEUE	$04
 	DB_OK_RECNO	$08
	u_int32_t	am_ok;		(* Legal AM choices. *)

	(*
	 * This field really ought to be an AM_FLAG, but we have
	 * have run out of bits.  If/when we decide to split up
	 * the flags, we can incorporate it.
	 *)
	int	 preserve_fid;		(* Do not free fileid on close. *)

 	DB_AM_CHKSUM		$00000001 (* Checksumming *)
 	DB_AM_CL_WRITER		$00000002 (* Allow writes in client replica *)
 	DB_AM_COMPENSATE	$00000004 (* Created by compensating txn *)
 	DB_AM_CREATED		$00000008 (* Database was created upon open *)
 	DB_AM_CREATED_MSTR	$00000010 (* Encompassing file was created *)
 	DB_AM_DBM_ERROR		$00000020 (* Error in DBM/NDBM database *)
 	DB_AM_DELIMITER		$00000040 (* Variable length delimiter set *)
 	DB_AM_DISCARD		$00000080 (* Discard any cached pages *)
 	DB_AM_DUP		$00000100 (* DB_DUP *)
 	DB_AM_DUPSORT		$00000200 (* DB_DUPSORT *)
 	DB_AM_ENCRYPT		$00000400 (* Encryption *)
 	DB_AM_FIXEDLEN		$00000800 (* Fixed-length records *)
 	DB_AM_INMEM		$00001000 (* In-memory; no sync on close *)
 	DB_AM_INORDER		$00002000 (* DB_INORDER *)
 	DB_AM_IN_RENAME		$00004000 (* File is being renamed *)
 	DB_AM_NOT_DURABLE	$00008000 (* Do not log changes *)
 	DB_AM_OPEN_CALLED	$00010000 (* DB->open called *)
 	DB_AM_PAD		$00020000 (* Fixed-length record pad *)
 	DB_AM_PGDEF		$00040000 (* Page size was defaulted *)
 	DB_AM_RDONLY		$00080000 (* Database is readonly *)
 	DB_AM_READ_UNCOMMITTED	$00100000 (* Support degree 1 isolation *)
 	DB_AM_RECNUM		$00200000 (* DB_RECNUM *)
 	DB_AM_RECOVER		$00400000 (* DB opened by recovery routine *)
 	DB_AM_RENUMBER		$00800000 (* DB_RENUMBER *)
 	DB_AM_REVSPLITOFF	$01000000 (* DB_REVSPLITOFF *)
 	DB_AM_SECONDARY		$02000000 (* Database is a secondary index *)
 	DB_AM_SNAPSHOT		$04000000 (* DB_SNAPSHOT *)
 	DB_AM_SUBDB		$08000000 (* Subdatabases supported *)
 	DB_AM_SWAP		$10000000 (* Pages need to be byte-swapped *)
 	DB_AM_TXN		$20000000 (* Opened in a transaction *)
 	DB_AM_VERIFYING		$40000000 (* DB handle is in the verifier *)
	u_int32_t orig_flags;		   (* Flags at  open, for refresh *)
	u_int32_t flags;
};

(*
 * Macros for bulk get.  These are only intended for the C API.
 * For C++, use DbMultiple*Iterator.
 *)
 	DB_MULTIPLE_INIT(pointer, dbt)					\
	(pointer = (u_int8_t *)(dbt)->data +				\
	    (dbt)->ulen - sizeof(u_int32_t))
 	DB_MULTIPLE_NEXT(pointer, dbt, retdata, retdlen)		\
	do {								\
		if (*((u_int32_t *)(pointer)) == (u_int32_t)-1) {	\
			retdata = NULL;					\
			pointer = NULL;					\
			break;						\
		}							\
		retdata = (u_int8_t *)					\
		    (dbt)->data + *(u_int32_t *)(pointer);		\
		(pointer) = (u_int32_t *)(pointer) - 1;			\
		retdlen = *(u_int32_t *)(pointer);			\
		(pointer) = (u_int32_t *)(pointer) - 1;			\
		if (retdlen == 0 &&					\
		    retdata == (u_int8_t *)(dbt)->data)			\
			retdata = NULL;					\
	} while (0)
 	DB_MULTIPLE_KEY_NEXT(pointer, dbt, retkey, retklen, retdata, retdlen) \
	do {								\
		if (*((u_int32_t *)(pointer)) == (u_int32_t)-1) {	\
			retdata = NULL;					\
			retkey = NULL;					\
			pointer = NULL;					\
			break;						\
		}							\
		retkey = (u_int8_t *)					\
		    (dbt)->data + *(u_int32_t *)(pointer);		\
		(pointer) = (u_int32_t *)(pointer) - 1;			\
		retklen = *(u_int32_t *)(pointer);			\
		(pointer) = (u_int32_t *)(pointer) - 1;			\
		retdata = (u_int8_t *)					\
		    (dbt)->data + *(u_int32_t *)(pointer);		\
		(pointer) = (u_int32_t *)(pointer) - 1;			\
		retdlen = *(u_int32_t *)(pointer);			\
		(pointer) = (u_int32_t *)(pointer) - 1;			\
	} while (0)

 	DB_MULTIPLE_RECNO_NEXT(pointer, dbt, recno, retdata, retdlen)   \
	do {								\
		if (*((u_int32_t *)(pointer)) == (u_int32_t)0) {	\
			recno = 0;					\
			retdata = NULL;					\
			pointer = NULL;					\
			break;						\
		}							\
		recno = *(u_int32_t *)(pointer);			\
		(pointer) = (u_int32_t *)(pointer) - 1;			\
		retdata = (u_int8_t *)					\
		    (dbt)->data + *(u_int32_t *)(pointer);		\
		(pointer) = (u_int32_t *)(pointer) - 1;			\
		retdlen = *(u_int32_t *)(pointer);			\
		(pointer) = (u_int32_t *)(pointer) - 1;			\
	} while (0)

(*******************************************************
 * Access method cursors.
 *******************************************************)
struct __dbc {
	DB *dbp;			(* Related DB access method. *)
	DB_TXN	 *txn;			(* Associated transaction. *)

	(*
	 * Active/free cursor queues.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(__dbc) links;
	 *)
	struct {
		DBC *tqe_next;
		DBC **tqe_prev;
	} links;

	(*
	 * The DBT *'s below are used by the cursor routines to return
	 * data to the user when DBT flags indicate that DB should manage
	 * the returned memory.  They point at a DBT containing the buffer
	 * and length that will be used, and 'belonging' to the handle that
	 * should 'own' this memory.  This may be a 'my_*' field of this
	 * cursor--the default--or it may be the corresponding field of
	 * another cursor, a DB handle, a join cursor, etc.  In general, it
	 * will be whatever handle the user originally used for the current
	 * DB interface call.
	 *)
	DBT	 *rskey;		(* Returned secondary key. *)
	DBT	 *rkey;			(* Returned [primary] key. *)
	DBT	 *rdata;		(* Returned data. *)

	DBT	  my_rskey;		(* Space for returned secondary key. *)
	DBT	  my_rkey;		(* Space for returned [primary] key. *)
	DBT	  my_rdata;		(* Space for returned data. *)

	void	 *lref;			(* Reference to default locker. *)
	u_int32_t locker;		(* Locker for this operation. *)
	DBT	  lock_dbt;		(* DBT referencing lock. *)
	DB_LOCK_ILOCK lock;		(* Object to be locked. *)
	DB_LOCK	  mylock;		(* CDB lock held on this cursor. *)

	u_int	  cl_id;		(* Remote client id. *)

	DBTYPE	  dbtype;		(* Cursor type. *)

	DBC_INTERNAL *internal;		(* Access method private. *)

	(* DBC PUBLIC HANDLE LIST BEGIN *)
	int (*c_close) __P((DBC *));
	int (*c_count) __P((DBC *, db_recno_t *, u_int32_t));
	int (*c_del) __P((DBC *, u_int32_t));
	int (*c_dup) __P((DBC *, DBC **, u_int32_t));
	int (*c_get) __P((DBC *, DBT *, DBT *, u_int32_t));
	int (*c_pget) __P((DBC *, DBT *, DBT *, DBT *, u_int32_t));
	int (*c_put) __P((DBC *, DBT *, DBT *, u_int32_t));
	(* DBC PUBLIC HANDLE LIST END *)

	(* DBC PRIVATE HANDLE LIST BEGIN *)
	int (*c_am_bulk) __P((DBC *, DBT *, u_int32_t));
	int (*c_am_close) __P((DBC *, db_pgno_t, int *));
	int (*c_am_del) __P((DBC *));
	int (*c_am_destroy) __P((DBC *));
	int (*c_am_get) __P((DBC *, DBT *, DBT *, u_int32_t, db_pgno_t *));
	int (*c_am_put) __P((DBC *, DBT *, DBT *, u_int32_t, db_pgno_t *));
	int (*c_am_writelock) __P((DBC *));
	(* DBC PRIVATE HANDLE LIST END *)

(*
 * DBC_DONTLOCK and DBC_RECOVER are used during recovery and transaction
 * abort.  If a transaction is being aborted or recovered then DBC_RECOVER
 * will be set and locking and logging will be disabled on this cursor.  If
 * we are performing a compensating transaction (e.g. free page processing)
 * then DB_DONTLOCK will be set to inhibit locking, but logging will still
 * be required. DB_DONTLOCK is also used if the whole database is locked.
 *)
 	DBC_ACTIVE		$0001	(* Cursor in use. *)
 	DBC_DONTLOCK		$0002	(* Don't lock on this cursor. *)
 	DBC_MULTIPLE		$0004	(* Return Multiple data. *)
 	DBC_MULTIPLE_KEY	$0008	(* Return Multiple keys and data. *)
 	DBC_OPD			$0010	(* Cursor references off-page dups. *)
 	DBC_OWN_LID		$0020	(* Free lock id on destroy. *)
 	DBC_READ_COMMITTED	$0040	(* Cursor has degree 2 isolation. *)
 	DBC_READ_UNCOMMITTED	$0080	(* Cursor has degree 1 isolation. *)
 	DBC_RECOVER		$0100	(* Recovery cursor; don't log/lock. *)
 	DBC_RMW			$0200	(* Acquire write flag in read op. *)
 	DBC_TRANSIENT		$0400	(* Cursor is transient. *)
 	DBC_WRITECURSOR		$0800	(* Cursor may be used to write (CDB). *)
 	DBC_WRITER		$1000	(* Cursor immediately writing (CDB). *)
	u_int32_t flags;
};

(* Key range statistics structure *)
struct __key_range {
	double less;
	double equal;
	double greater;
};

(* Btree/Recno statistics structure. *)
struct __db_bt_stat {
	u_int32_t bt_magic;		(* Magic number. *)
	u_int32_t bt_version;		(* Version number. *)
	u_int32_t bt_metaflags;		(* Metadata flags. *)
	u_int32_t bt_nkeys;		(* Number of unique keys. *)
	u_int32_t bt_ndata;		(* Number of data items. *)
	u_int32_t bt_pagesize;		(* Page size. *)
	u_int32_t bt_minkey;		(* Minkey value. *)
	u_int32_t bt_re_len;		(* Fixed-length record length. *)
	u_int32_t bt_re_pad;		(* Fixed-length record pad. *)
	u_int32_t bt_levels;		(* Tree levels. *)
	u_int32_t bt_int_pg;		(* Internal pages. *)
	u_int32_t bt_leaf_pg;		(* Leaf pages. *)
	u_int32_t bt_dup_pg;		(* Duplicate pages. *)
	u_int32_t bt_over_pg;		(* Overflow pages. *)
	u_int32_t bt_empty_pg;		(* Empty pages. *)
	u_int32_t bt_free;		(* Pages on the free list. *)
	u_int32_t bt_int_pgfree;	(* Bytes free in internal pages. *)
	u_int32_t bt_leaf_pgfree;	(* Bytes free in leaf pages. *)
	u_int32_t bt_dup_pgfree;	(* Bytes free in duplicate pages. *)
	u_int32_t bt_over_pgfree;	(* Bytes free in overflow pages. *)
};

struct __db_compact {
	(* Input Parameters. *)
	u_int32_t	compact_fillpercent;	(* Desired fillfactor: 1-100 *)
	db_timeout_t	compact_timeout;	(* Lock timeout. *)
	u_int32_t	compact_pages;		(* Max pages to process. *)
	(* Output Stats. *)
	u_int32_t	compact_pages_free;	(* Number of pages freed. *)
	u_int32_t	compact_pages_examine;	(* Number of pages examine. *)
	u_int32_t	compact_levels;		(* Number of levels removed. *)
	u_int32_t	compact_deadlock;	(* Number of deadlocks. *)
	db_pgno_t	compact_pages_truncated; (* Pages truncated to OS. *)
	(* Internal. *)
	db_pgno_t	compact_truncate;	(* Page number for truncation *)
};

(* Hash statistics structure. *)
struct __db_h_stat {
	u_int32_t hash_magic;		(* Magic number. *)
	u_int32_t hash_version;		(* Version number. *)
	u_int32_t hash_metaflags;	(* Metadata flags. *)
	u_int32_t hash_nkeys;		(* Number of unique keys. *)
	u_int32_t hash_ndata;		(* Number of data items. *)
	u_int32_t hash_pagesize;	(* Page size. *)
	u_int32_t hash_ffactor;		(* Fill factor specified at create. *)
	u_int32_t hash_buckets;		(* Number of hash buckets. *)
	u_int32_t hash_free;		(* Pages on the free list. *)
	u_int32_t hash_bfree;		(* Bytes free on bucket pages. *)
	u_int32_t hash_bigpages;	(* Number of big key/data pages. *)
	u_int32_t hash_big_bfree;	(* Bytes free on big item pages. *)
	u_int32_t hash_overflows;	(* Number of overflow pages. *)
	u_int32_t hash_ovfl_free;	(* Bytes free on ovfl pages. *)
	u_int32_t hash_dup;		(* Number of dup pages. *)
	u_int32_t hash_dup_free;	(* Bytes free on duplicate pages. *)
};

(* Queue statistics structure. *)
struct __db_qam_stat {
	u_int32_t qs_magic;		(* Magic number. *)
	u_int32_t qs_version;		(* Version number. *)
	u_int32_t qs_metaflags;		(* Metadata flags. *)
	u_int32_t qs_nkeys;		(* Number of unique keys. *)
	u_int32_t qs_ndata;		(* Number of data items. *)
	u_int32_t qs_pagesize;		(* Page size. *)
	u_int32_t qs_extentsize;	(* Pages per extent. *)
	u_int32_t qs_pages;		(* Data pages. *)
	u_int32_t qs_re_len;		(* Fixed-length record length. *)
	u_int32_t qs_re_pad;		(* Fixed-length record pad. *)
	u_int32_t qs_pgfree;		(* Bytes free in data pages. *)
	u_int32_t qs_first_recno;	(* First not deleted record. *)
	u_int32_t qs_cur_recno;		(* Next available record number. *)
};

(*******************************************************
 * Environment.
 *******************************************************)
 	DB_REGION_MAGIC	$120897	(* Environment magic number. *)

(* Database Environment handle. *)
struct __db_env {
	(*******************************************************
	 * Public: owned by the application.
	 *******************************************************)
					(* Error message callback. *)
	void (*db_errcall) __P((const DB_ENV *, const char *, const char *));
	FILE		*db_errfile;	(* Error message file stream. *)
	const char	*db_errpfx;	(* Error message prefix. *)

	FILE		*db_msgfile;	(* Statistics message file stream. *)
					(* Statistics message callback. *)
	void (*db_msgcall) __P((const DB_ENV *, const char *));

					(* Other Callbacks. *)
	void (*db_feedback) __P((DB_ENV *, int, int));
	void (*db_paniccall) __P((DB_ENV *, int));
	void (*db_event_func) __P((DB_ENV *, u_int32_t, Pointer ));

					(* App-specified alloc functions. *)
	Pointer (*db_malloc) __P((size_t));
	Pointer (*db_realloc) __P((Pointer , size_t));
	void (*db_free) __P((Pointer ));

	(* Application callback to copy data to/from a custom data source. *)
 	DB_USERCOPY_GETDATA	$0001
 	DB_USERCOPY_SETDATA	$0002
	int (*dbt_usercopy)
	    __P((DBT *, u_int32_t, Pointer , u_int32_t, u_int32_t));

	(*
	 * Currently, the verbose list is a bit field with room for 32
	 * entries.  There's no reason that it needs to be limited, if
	 * there are ever more than 32 entries, convert to a bit array.
	 *)
 	DB_VERB_DEADLOCK	$0001	(* Deadlock detection information. *)
 	DB_VERB_RECOVERY	$0002	(* Recovery information. *)
 	DB_VERB_REGISTER	$0004	(* Dump waits-for table. *)
 	DB_VERB_REPLICATION	$0008	(* Replication information. *)
 	DB_VERB_WAITSFOR	$0010	(* Dump waits-for table. *)
	u_int32_t	 verbose;	(* Verbose output. *)

	void		*app_private;	(* Application-private handle. *)

	int (*app_dispatch)		(* User-specified recovery dispatch. *)
	    __P((DB_ENV *, DBT *, DB_LSN *, db_recops));

	(* Mutexes. *)
	u_int32_t	mutex_align;	(* Mutex alignment *)
	u_int32_t	mutex_cnt;	(* Number of mutexes to configure *)
	u_int32_t	mutex_inc;	(* Number of mutexes to add *)
	u_int32_t	mutex_tas_spins;(* Test-and-set spin count *)

	struct {
		int	  alloc_id;	(* Allocation ID argument *)
		u_int32_t flags;	(* Flags argument *)
	} *mutex_iq;			(* Initial mutexes queue *)
	u_int		mutex_iq_next;	(* Count of initial mutexes *)
	u_int		mutex_iq_max;	(* Maximum initial mutexes *)

	(* Locking. *)
	u_int8_t	*lk_conflicts;	(* Two dimensional conflict matrix. *)
	int		 lk_modes;	(* Number of lock modes in table. *)
	u_int32_t	 lk_max;	(* Maximum number of locks. *)
	u_int32_t	 lk_max_lockers;(* Maximum number of lockers. *)
	u_int32_t	 lk_max_objects;(* Maximum number of locked objects. *)
	u_int32_t	 lk_detect;	(* Deadlock detect on all conflicts. *)
	db_timeout_t	 lk_timeout;	(* Lock timeout period. *)

	(* Logging. *)
	u_int32_t	 lg_bsize;	(* Buffer size. *)
	u_int32_t	 lg_size;	(* Log file size. *)
	u_int32_t	 lg_regionmax;	(* Region size. *)
	int		 lg_filemode;	(* Log file permission mode. *)

	(* Memory pool. *)
	u_int32_t	 mp_gbytes;	(* Cachesize: GB. *)
	u_int32_t	 mp_bytes;	(* Cachesize: Bytes. *)
	u_int		 mp_ncache;	(* Number of cache regions. *)
	size_t		 mp_mmapsize;	(* Maximum file size for mmap. *)
	int		 mp_maxopenfd;	(* Maximum open file descriptors. *)
	int		 mp_maxwrite;	(* Maximum buffers to write. *)
	int				(* Sleep after writing max buffers. *)
			 mp_maxwrite_sleep;

	(* Transactions. *)
	u_int32_t	 tx_max;	(* Maximum number of transactions. *)
	time_t		 tx_timestamp;	(* Recover to specific timestamp. *)
	db_timeout_t	 tx_timeout;	(* Timeout for transactions. *)

	(* Thread tracking. *)
	u_int32_t	thr_nbucket;	(* Number of hash buckets. *)
	u_int32_t	thr_max;	(* Max before garbage collection. *)
	void		*thr_hashtab;	(* Hash table of DB_THREAD_INFO. *)

	(*******************************************************
	 * Private: owned by DB.
	 *******************************************************)
	pid_t		pid_cache;	(* Cached process ID. *)

					(* User files, paths. *)
	char		*db_home;	(* Database home. *)
	char		*db_log_dir;	(* Database log file directory. *)
	char		*db_tmp_dir;	(* Database tmp file directory. *)

	char	       **db_data_dir;	(* Database data file directories. *)
	int		 data_cnt;	(* Database data file slots. *)
	int		 data_next;	(* Next Database data file slot. *)

	int		 db_mode;	(* Default open permissions. *)
	int		 dir_mode;	(* Intermediate directory perms. *)
	void		*env_lref;	(* Locker in non-threaded handles. *)
	u_int32_t	 open_flags;	(* Flags passed to DB_ENV->open. *)

	void		*reginfo;	(* REGINFO structure reference. *)
	DB_FH		*lockfhp;	(* fcntl(2) locking file handle. *)

	DB_FH		*registry;	(* DB_REGISTER file handle. *)
	u_int32_t	registry_off;	(*
					 * Offset of our slot.  We can't use
					 * off_t because its size depends on
					 * build settings.
					 *)

					(* Return IDs. *)
	void	       (*thread_id) __P((DB_ENV *, pid_t *, db_threadid_t *));
					(* Return if IDs alive. *)
	int	       (*is_alive)
			__P((DB_ENV *, pid_t, db_threadid_t, u_int32_t));
					(* Format IDs into a string. *)
	char	       *(*thread_id_string)
			__P((DB_ENV *, pid_t, db_threadid_t, char *));

	int	      (**recover_dtab)	(* Dispatch table for recover funcs. *)
			    __P((DB_ENV *, DBT *, DB_LSN *, db_recops, Pointer ));
	size_t		 recover_dtab_size;
					(* Slots in the dispatch table. *)

	void		*cl_handle;	(* RPC: remote client handle. *)
	u_int		 cl_id;		(* RPC: remote client env id. *)

	int		 db_ref;	(* DB reference count. *)

	long		 shm_key;	(* shmget(2) key. *)

	(*
	 * List of open DB handles for this DB_ENV, used for cursor
	 * adjustment.  Must be protected for multi-threaded support.
	 *
	 * !!!
	 * As this structure is allocated in per-process memory, the
	 * mutex may need to be stored elsewhere on architectures unable
	 * to support mutexes in heap memory, e.g. HP/UX 9.
	 *
	 * !!!
	 * Explicit representation of structure in queue.h.
	 * TAILQ_HEAD(__dblist, __db);
	 *)
	db_mutex_t mtx_dblist;		(* Mutex. *)
	struct __dblist {
		struct __db *tqh_first;
		struct __db **tqh_last;
	} dblist;

	(*
	 * XA support.
	 *
	 * !!!
	 * Explicit representations of structures from queue.h.
	 * TAILQ_ENTRY(__db_env) links;
	 * TAILQ_HEAD(xa_txn, __db_txn);
	 *)
	struct {
		struct __db_env *tqe_next;
		struct __db_env **tqe_prev;
	} links;
	struct __xa_txn {	(* XA Active Transactions. *)
		struct __db_txn *tqh_first;
		struct __db_txn **tqh_last;
	} xa_txn;
	int		 xa_rmid;	(* XA Resource Manager ID. *)

	char		*passwd;	(* Cryptography support. *)
	size_t		 passwd_len;
	void		*crypto_handle;	(* Primary handle. *)
	db_mutex_t	 mtx_mt;	(* Mersenne Twister mutex. *)
	int		 mti;		(* Mersenne Twister index. *)
	u_long		*mt;		(* Mersenne Twister state vector. *)

	(* API-private structure. *)
	void		*api1_internal;	(* C++, Perl API private *)
	void		*api2_internal;	(* Java API private *)

	DB_LOCKTAB	*lk_handle;	(* Lock handle. *)
	DB_LOG		*lg_handle;	(* Log handle. *)
	DB_MPOOL	*mp_handle;	(* Mpool handle. *)
	DB_MUTEXMGR	*mutex_handle;	(* Mutex handle. *)
	DB_REP		*rep_handle;	(* Replication handle. *)
	DB_TXNMGR	*tx_handle;	(* Txn handle. *)

	(* DB_ENV PUBLIC HANDLE LIST BEGIN *)
	int  (*cdsgroup_begin) __P((DB_ENV *, DB_TXN **));
	int  (*close) __P((DB_ENV *, u_int32_t));
	int  (*dbremove) __P((DB_ENV *,
		DB_TXN *, const char *, const char *, u_int32_t));
	int  (*dbrename) __P((DB_ENV *,
		DB_TXN *, const char *, const char *, const char *, u_int32_t));
	void (*err) __P((const DB_ENV *, int, const char *, ...));
	void (*errx) __P((const DB_ENV *, const char *, ...));
	int  (*failchk) __P((DB_ENV *, u_int32_t));
	int  (*fileid_reset) __P((DB_ENV *, const char *, u_int32_t));
	int  (*get_cachesize) __P((DB_ENV *, u_int32_t *, u_int32_t *, int *));
	int  (*get_data_dirs) __P((DB_ENV *, const char ***));
	int  (*get_encrypt_flags) __P((DB_ENV *, u_int32_t *));
	void (*get_errfile) __P((DB_ENV *, FILE **));
	void (*get_errpfx) __P((DB_ENV *, const char **));
	int  (*get_flags) __P((DB_ENV *, u_int32_t *));
	int  (*get_home) __P((DB_ENV *, const char **));
	int  (*get_lg_bsize) __P((DB_ENV *, u_int32_t *));
	int  (*get_lg_dir) __P((DB_ENV *, const char **));
	int  (*get_lg_filemode) __P((DB_ENV *, int *));
	int  (*get_lg_max) __P((DB_ENV *, u_int32_t *));
	int  (*get_lg_regionmax) __P((DB_ENV *, u_int32_t *));
	int  (*get_lk_conflicts) __P((DB_ENV *, const u_int8_t **, int *));
	int  (*get_lk_detect) __P((DB_ENV *, u_int32_t *));
	int  (*get_lk_max_lockers) __P((DB_ENV *, u_int32_t *));
	int  (*get_lk_max_locks) __P((DB_ENV *, u_int32_t *));
	int  (*get_lk_max_objects) __P((DB_ENV *, u_int32_t *));
	int  (*get_mp_max_openfd) __P((DB_ENV *, int *));
	int  (*get_mp_max_write) __P((DB_ENV *, int *, int *));
	int  (*get_mp_mmapsize) __P((DB_ENV *, size_t *));
	void (*get_msgfile) __P((DB_ENV *, FILE **));
	int  (*get_open_flags) __P((DB_ENV *, u_int32_t *));
	int  (*get_shm_key) __P((DB_ENV *, long *));
	int  (*get_timeout) __P((DB_ENV *, db_timeout_t *, u_int32_t));
	int  (*get_tmp_dir) __P((DB_ENV *, const char **));
	int  (*get_tx_max) __P((DB_ENV *, u_int32_t *));
	int  (*get_tx_timestamp) __P((DB_ENV *, time_t *));
	int  (*get_verbose) __P((DB_ENV *, u_int32_t, int *));
	int  (*is_bigendian) __P((void));
	int  (*lock_detect) __P((DB_ENV *, u_int32_t, u_int32_t, int *));
	int  (*lock_get) __P((DB_ENV *,
		u_int32_t, u_int32_t, const DBT *, db_lockmode_t, DB_LOCK *));
	int  (*lock_id) __P((DB_ENV *, u_int32_t *));
	int  (*lock_id_free) __P((DB_ENV *, u_int32_t));
	int  (*lock_put) __P((DB_ENV *, DB_LOCK *));
	int  (*lock_stat) __P((DB_ENV *, DB_LOCK_STAT **, u_int32_t));
	int  (*lock_stat_print) __P((DB_ENV *, u_int32_t));
	int  (*lock_vec) __P((DB_ENV *,
		u_int32_t, u_int32_t, DB_LOCKREQ *, int, DB_LOCKREQ **));
	int  (*log_archive) __P((DB_ENV *, char **[], u_int32_t));
	int  (*log_cursor) __P((DB_ENV *, DB_LOGC **, u_int32_t));
	int  (*log_file) __P((DB_ENV *, const DB_LSN *, char *, size_t));
	int  (*log_flush) __P((DB_ENV *, const DB_LSN *));
	int  (*log_printf) __P((DB_ENV *, DB_TXN *, const char *, ...));
	int  (*log_put) __P((DB_ENV *, DB_LSN *, const DBT *, u_int32_t));
	int  (*log_stat) __P((DB_ENV *, DB_LOG_STAT **, u_int32_t));
	int  (*log_stat_print) __P((DB_ENV *, u_int32_t));
	int  (*lsn_reset) __P((DB_ENV *, const char *, u_int32_t));
	int  (*memp_fcreate) __P((DB_ENV *, DB_MPOOLFILE **, u_int32_t));
	int  (*memp_register) __P((DB_ENV *, int, int (*)(DB_ENV *,
		db_pgno_t, Pointer , DBT *), int (*)(DB_ENV *,
		db_pgno_t, Pointer , DBT *)));
	int  (*memp_stat) __P((DB_ENV *,
		DB_MPOOL_STAT **, DB_MPOOL_FSTAT ***, u_int32_t));
	int  (*memp_stat_print) __P((DB_ENV *, u_int32_t));
	int  (*memp_sync) __P((DB_ENV *, DB_LSN *));
	int  (*memp_trickle) __P((DB_ENV *, int, int *));
	int  (*mutex_alloc) __P((DB_ENV *, u_int32_t, db_mutex_t *));
	int  (*mutex_free) __P((DB_ENV *, db_mutex_t));
	int  (*mutex_get_align) __P((DB_ENV *, u_int32_t *));
	int  (*mutex_get_increment) __P((DB_ENV *, u_int32_t *));
	int  (*mutex_get_max) __P((DB_ENV *, u_int32_t *));
	int  (*mutex_get_tas_spins) __P((DB_ENV *, u_int32_t *));
	int  (*mutex_lock) __P((DB_ENV *, db_mutex_t));
	int  (*mutex_set_align) __P((DB_ENV *, u_int32_t));
	int  (*mutex_set_increment) __P((DB_ENV *, u_int32_t));
	int  (*mutex_set_max) __P((DB_ENV *, u_int32_t));
	int  (*mutex_set_tas_spins) __P((DB_ENV *, u_int32_t));
	int  (*mutex_stat) __P((DB_ENV *, DB_MUTEX_STAT **, u_int32_t));
	int  (*mutex_stat_print) __P((DB_ENV *, u_int32_t));
	int  (*mutex_unlock) __P((DB_ENV *, db_mutex_t));
	int  (*open) __P((DB_ENV *, const char *, u_int32_t, int));
	int  (*remove) __P((DB_ENV *, const char *, u_int32_t));
	int  (*rep_elect)
		__P((DB_ENV *, int, int, int *, u_int32_t));
	int  (*rep_flush) __P((DB_ENV *));
	int  (*rep_get_config) __P((DB_ENV *, u_int32_t, int *));
	int  (*rep_get_limit) __P((DB_ENV *, u_int32_t *, u_int32_t *));
	int  (*rep_get_nsites) __P((DB_ENV *, int *));
	int  (*rep_get_priority) __P((DB_ENV *, int *));
	int  (*rep_get_timeout) __P((DB_ENV *, int, u_int32_t *));
	int  (*rep_process_message)
		__P((DB_ENV *, DBT *, DBT *, int *, DB_LSN *));
	int  (*rep_set_config) __P((DB_ENV *, u_int32_t, int));
	int  (*rep_set_limit) __P((DB_ENV *, u_int32_t, u_int32_t));
	int  (*rep_set_nsites) __P((DB_ENV *, int));
	int  (*rep_set_priority) __P((DB_ENV *, int));
	int  (*rep_set_timeout) __P((DB_ENV *, int, db_timeout_t));
	int  (*rep_set_transport) __P((DB_ENV *, int, int (*)(DB_ENV *,
		const DBT *, const DBT *, const DB_LSN *, int, u_int32_t)));
	int  (*rep_start) __P((DB_ENV *, DBT *, u_int32_t));
	int  (*rep_stat) __P((DB_ENV *, DB_REP_STAT **, u_int32_t));
	int  (*rep_stat_print) __P((DB_ENV *, u_int32_t));
	int  (*rep_sync) __P((DB_ENV *, u_int32_t));
	int  (*repmgr_add_remote_site) __P((DB_ENV *, const char *, u_int,
		int *, u_int32_t));
	int  (*repmgr_get_ack_policy) __P((DB_ENV *, int *));
	int  (*repmgr_set_ack_policy) __P((DB_ENV *, int));
	int  (*repmgr_set_local_site) __P((DB_ENV *, const char *, u_int,
		u_int32_t));
	int  (*repmgr_site_list) __P((DB_ENV *, u_int *,
		DB_REPMGR_SITE **));
	int  (*repmgr_start) __P((DB_ENV *, int, u_int32_t));
	int  (*set_alloc) __P((DB_ENV *, Pointer (*)(size_t),
		Pointer (*)(Pointer , size_t), void (*)(Pointer )));
	int  (*set_app_dispatch)
		__P((DB_ENV *, int (*)(DB_ENV *, DBT *, DB_LSN *, db_recops)));
	int  (*set_cachesize) __P((DB_ENV *, u_int32_t, u_int32_t, int));
	int  (*set_data_dir) __P((DB_ENV *, const char *));
	int  (*set_encrypt) __P((DB_ENV *, const char *, u_int32_t));
	void (*set_errcall) __P((DB_ENV *,
		void (*)(const DB_ENV *, const char *, const char *)));
	void (*set_errfile) __P((DB_ENV *, FILE *));
	void (*set_errpfx) __P((DB_ENV *, const char *));
	int  (*set_event_notify)
		__P((DB_ENV *, void (*)(DB_ENV *, u_int32_t, Pointer )));
	int  (*set_feedback) __P((DB_ENV *, void (*)(DB_ENV *, int, int)));
	int  (*set_flags) __P((DB_ENV *, u_int32_t, int));
	int  (*set_intermediate_dir) __P((DB_ENV *, int, u_int32_t));
	int  (*set_isalive) __P((DB_ENV *,
		int (*)(DB_ENV *, pid_t, db_threadid_t, u_int32_t)));
	int  (*set_lg_bsize) __P((DB_ENV *, u_int32_t));
	int  (*set_lg_dir) __P((DB_ENV *, const char *));
	int  (*set_lg_filemode) __P((DB_ENV *, int));
	int  (*set_lg_max) __P((DB_ENV *, u_int32_t));
	int  (*set_lg_regionmax) __P((DB_ENV *, u_int32_t));
	int  (*set_lk_conflicts) __P((DB_ENV *, u_int8_t *, int));
	int  (*set_lk_detect) __P((DB_ENV *, u_int32_t));
	int  (*set_lk_max_lockers) __P((DB_ENV *, u_int32_t));
	int  (*set_lk_max_locks) __P((DB_ENV *, u_int32_t));
	int  (*set_lk_max_objects) __P((DB_ENV *, u_int32_t));
	int  (*set_mp_max_openfd) __P((DB_ENV *, int));
	int  (*set_mp_max_write) __P((DB_ENV *, int, int));
	int  (*set_mp_mmapsize) __P((DB_ENV *, size_t));
	void (*set_msgcall)
		__P((DB_ENV *, void (*)(const DB_ENV *, const char *)));
	void (*set_msgfile) __P((DB_ENV *, FILE *));
	int  (*set_paniccall) __P((DB_ENV *, void (*)(DB_ENV *, int)));
	int  (*set_rep_request) __P((DB_ENV *, u_int32_t, u_int32_t));
	int  (*set_rpc_server)
		__P((DB_ENV *, Pointer , const char *, long, long, u_int32_t));
	int  (*set_shm_key) __P((DB_ENV *, long));
	int  (*set_thread_count) __P((DB_ENV *, u_int32_t));
	int  (*set_thread_id) __P((DB_ENV *,
		void (*)(DB_ENV *, pid_t *, db_threadid_t *)));
	int  (*set_thread_id_string) __P((DB_ENV *,
		char *(*)(DB_ENV *, pid_t, db_threadid_t, char *)));
	int  (*set_timeout) __P((DB_ENV *, db_timeout_t, u_int32_t));
	int  (*set_tmp_dir) __P((DB_ENV *, const char *));
	int  (*set_tx_max) __P((DB_ENV *, u_int32_t));
	int  (*set_tx_timestamp) __P((DB_ENV *, time_t *));
	int  (*set_verbose) __P((DB_ENV *, u_int32_t, int));
	int  (*stat_print) __P((DB_ENV *, u_int32_t));
	int  (*txn_begin) __P((DB_ENV *, DB_TXN *, DB_TXN **, u_int32_t));
	int  (*txn_checkpoint) __P((DB_ENV *, u_int32_t, u_int32_t, u_int32_t));
	int  (*txn_recover)
		__P((DB_ENV *, DB_PREPLIST *, long, long *, u_int32_t));
	int  (*txn_stat) __P((DB_ENV *, DB_TXN_STAT **, u_int32_t));
	int  (*txn_stat_print) __P((DB_ENV *, u_int32_t));
	(* DB_ENV PUBLIC HANDLE LIST END *)

	(* DB_ENV PRIVATE HANDLE LIST BEGIN *)
	int  (*prdbt) __P((DBT *,
		int, const char *, Pointer , int (*)(Pointer , const Pointer ), int));
	(* DB_ENV PRIVATE HANDLE LIST END *)

 	DB_TEST_ELECTINIT	 1	(* after __rep_elect_init *)
 	DB_TEST_ELECTVOTE1	 2	(* after sending VOTE1 *)
 	DB_TEST_POSTDESTROY	 3	(* after destroy op *)
 	DB_TEST_POSTLOG		 4	(* after logging all pages *)
 	DB_TEST_POSTLOGMETA	 5	(* after logging meta in btree *)
 	DB_TEST_POSTOPEN	 6	(* after __os_open *)
 	DB_TEST_POSTSYNC	 7	(* after syncing the log *)
 	DB_TEST_PREDESTROY	 8	(* before destroy op *)
 	DB_TEST_PREOPEN		 9	(* before __os_open *)
 	DB_TEST_RECYCLE		 10	(* test rep and txn_recycle *)
 	DB_TEST_SUBDB_LOCKS	 11	(* subdb locking tests *)
	int		 test_abort;	(* Abort value for testing. *)
	int		 test_check;	(* Checkpoint value for testing. *)
	int		 test_copy;	(* Copy value for testing. *)

 	DB_ENV_AUTO_COMMIT	$00000001 (* DB_AUTO_COMMIT. *)
 	DB_ENV_CDB		$00000002 (* DB_INIT_CDB. *)
 	DB_ENV_CDB_ALLDB	$00000004 (* CDB environment wide locking. *)
 	DB_ENV_CREATE		$00000008 (* DB_CREATE set. *)
 	DB_ENV_DBLOCAL		$00000010 (* Environment for a private DB. *)
 	DB_ENV_DIRECT_DB	$00000020 (* DB_DIRECT_DB set. *)
 	DB_ENV_DIRECT_LOG	$00000040 (* DB_DIRECT_LOG set. *)
 	DB_ENV_DSYNC_DB		$00000080 (* DB_DSYNC_DB set. *)
 	DB_ENV_DSYNC_LOG	$00000100 (* DB_DSYNC_LOG set. *)
 	DB_ENV_FATAL		$00000200 (* Doing fatal recovery in env. *)
 	DB_ENV_LOCKDOWN		$00000400 (* DB_LOCKDOWN set. *)
 	DB_ENV_LOG_AUTOREMOVE   $00000800 (* DB_LOG_AUTOREMOVE set. *)
 	DB_ENV_LOG_INMEMORY     $00001000 (* DB_LOG_INMEMORY set. *)
 	DB_ENV_MULTIVERSION	$00002000 (* DB_MULTIVERSION set. *)
 	DB_ENV_NOLOCKING	$00004000 (* DB_NOLOCKING set. *)
 	DB_ENV_NOMMAP		$00008000 (* DB_NOMMAP set. *)
 	DB_ENV_NOPANIC		$00010000 (* Okay if panic set. *)
 	DB_ENV_OPEN_CALLED	$00020000 (* DB_ENV->open called. *)
 	DB_ENV_OVERWRITE	$00040000 (* DB_OVERWRITE set. *)
 	DB_ENV_PRIVATE		$00080000 (* DB_PRIVATE set. *)
 	DB_ENV_REGION_INIT	$00100000 (* DB_REGION_INIT set. *)
 	DB_ENV_RPCCLIENT	$00200000 (* DB_RPCCLIENT set. *)
 	DB_ENV_RPCCLIENT_GIVEN	$00400000 (* User-supplied RPC client struct *)
 	DB_ENV_SYSTEM_MEM	$00800000 (* DB_SYSTEM_MEM set. *)
 	DB_ENV_THREAD		$01000000 (* DB_THREAD set. *)
 	DB_ENV_TIME_NOTGRANTED	$02000000 (* DB_TIME_NOTGRANTED set. *)
 	DB_ENV_TXN_NOSYNC	$04000000 (* DB_TXN_NOSYNC set. *)
 	DB_ENV_TXN_SNAPSHOT	$08000000 (* DB_TXN_SNAPSHOT set. *)
 	DB_ENV_TXN_WRITE_NOSYNC	$10000000 (* DB_TXN_WRITE_NOSYNC set. *)
 	DB_ENV_YIELDCPU		$20000000 (* DB_YIELDCPU set. *)
	u_int32_t flags;
};

#ifndef DB_DBM_HSEARCH
 	DB_DBM_HSEARCH	0		(* No historic interfaces by default. *)
#endif
#if DB_DBM_HSEARCH != 0
(*******************************************************
 * Dbm/Ndbm historic interfaces.
 *******************************************************)
type struct __db DBM;

 	DBM_INSERT	0		(* Flags to dbm_store(). *)
 	DBM_REPLACE	1

(*
 * The DB support for ndbm(3) always appends this suffix to the
 * file name to avoid overwriting the user's original database.
 *)
 	DBM_SUFFIX	'.db'

#if defined(_XPG4_2)
type struct {
	char *dptr;
	size_t dsize;
} datum;
#else
type struct {
	char *dptr;
	int dsize;
} datum;
#endif

(*
 * Translate NDBM calls into DB calls so that DB doesn't step on the
 * application's name space.
 *)
 	dbm_clearerr(a)		__db_ndbm_clearerr(a)
 	dbm_close(a)		__db_ndbm_close(a)
 	dbm_delete(a, b)	__db_ndbm_delete(a, b)
 	dbm_dirfno(a)		__db_ndbm_dirfno(a)
 	dbm_error(a)		__db_ndbm_error(a)
 	dbm_fetch(a, b)		__db_ndbm_fetch(a, b)
 	dbm_firstkey(a)		__db_ndbm_firstkey(a)
 	dbm_nextkey(a)		__db_ndbm_nextkey(a)
 	dbm_open(a, b, c)	__db_ndbm_open(a, b, c)
 	dbm_pagfno(a)		__db_ndbm_pagfno(a)
 	dbm_rdonly(a)		__db_ndbm_rdonly(a)
 	dbm_store(a, b, c, d) \
	__db_ndbm_store(a, b, c, d)

(*
 * Translate DBM calls into DB calls so that DB doesn't step on the
 * application's name space.
 *
 * The global variables dbrdonly, dirf and pagf were not retained when 4BSD
 * replaced the dbm interface with ndbm, and are not supported here.
 *)
 	dbminit(a)	__db_dbm_init(a)
 	dbmclose	__db_dbm_close
#if !defined(__cplusplus)
 	delete(a)	__db_dbm_delete(a)
#endif
 	fetch(a)	__db_dbm_fetch(a)
 	firstkey	__db_dbm_firstkey
 	nextkey(a)	__db_dbm_nextkey(a)
 	store(a, b)	__db_dbm_store(a, b)

(*******************************************************
 * Hsearch historic interface.
 *******************************************************)
type enum {
	FIND, ENTER
} ACTION;

type struct entry {
	char *key;
	char *data;
} ENTRY;

 	hcreate(a)	__db_hcreate(a)
 	hdestroy	__db_hdestroy
 	hsearch(a, b)	__db_hsearch(a, b)

#endif (* DB_DBM_HSEARCH *)

#if defined(__cplusplus)
}
#endif

(* Restore default compiler warnings *)
#ifdef _MSC_VER
#pragma warning(pop)
#endif
#endif (* !_DB_H_ *)

(* DO NOT EDIT: automatically built by dist/s_include. *)
#ifndef	_DB_EXT_PROT_IN_
 	_DB_EXT_PROT_IN_


int db_create __P((DB **, DB_ENV *, u_int32_t));
char *db_strerror __P((int));
int db_env_create __P((DB_ENV **, u_int32_t));
char *db_version __P((int *, int *, int *));
int log_compare __P((const DB_LSN *, const DB_LSN *));
int db_env_set_func_close __P((int (*)(int)));
int db_env_set_func_dirfree __P((void (*)(char **, int)));
int db_env_set_func_dirlist __P((int (*)(const char *, char ***, int *)));
int db_env_set_func_exists __P((int (*)(const char *, int *)));
int db_env_set_func_free __P((void (*)(Pointer )));
int db_env_set_func_fsync __P((int (*)(int)));
int db_env_set_func_ftruncate __P((int (*)(int, off_t)));
int db_env_set_func_ioinfo __P((int (*)(const char *, int, u_int32_t *, u_int32_t *, u_int32_t *)));
int db_env_set_func_malloc __P((Pointer (*)(size_t)));
int db_env_set_func_map __P((int (*)(char *, size_t, int, int, Pointer *)));
int db_env_set_func_pread __P((ssize_t (*)(int, Pointer , size_t, off_t)));
int db_env_set_func_pwrite __P((ssize_t (*)(int, const Pointer , size_t, off_t)));
int db_env_set_func_open __P((int (*)(const char *, int, ...)));
int db_env_set_func_read __P((ssize_t (*)(int, Pointer , size_t)));
int db_env_set_func_realloc __P((Pointer (*)(Pointer , size_t)));
int db_env_set_func_rename __P((int (*)(const char *, const char *)));
int db_env_set_func_seek __P((int (*)(int, off_t, int)));
int db_env_set_func_sleep __P((int (*)(u_long, u_long)));
int db_env_set_func_unlink __P((int (*)(const char *)));
int db_env_set_func_unmap __P((int (*)(Pointer , size_t)));
int db_env_set_func_write __P((ssize_t (*)(int, const Pointer , size_t)));
int db_env_set_func_yield __P((int (*)(void)));
int db_sequence_create __P((DB_SEQUENCE **, DB *, u_int32_t));
#if DB_DBM_HSEARCH != 0
int	 __db_ndbm_clearerr __P((DBM *));
void	 __db_ndbm_close __P((DBM *));
int	 __db_ndbm_delete __P((DBM *, datum));
int	 __db_ndbm_dirfno __P((DBM *));
int	 __db_ndbm_error __P((DBM *));
datum __db_ndbm_fetch __P((DBM *, datum));
datum __db_ndbm_firstkey __P((DBM *));
datum __db_ndbm_nextkey __P((DBM *));
DBM	*__db_ndbm_open __P((const char *, int, int));
int	 __db_ndbm_pagfno __P((DBM *));
int	 __db_ndbm_rdonly __P((DBM *));
int	 __db_ndbm_store __P((DBM *, datum, datum, int));
int	 __db_dbm_close __P((void));
int	 __db_dbm_delete __P((datum));
datum __db_dbm_fetch __P((datum));
datum __db_dbm_firstkey __P((void));
int	 __db_dbm_init __P((char *));
datum __db_dbm_nextkey __P((datum));
int	 __db_dbm_store __P((datum, datum));
#endif
#if DB_DBM_HSEARCH != 0
int __db_hcreate __P((size_t));
ENTRY *__db_hsearch __P((ENTRY, ACTION));
void __db_hdestroy __P((void));
#endif

#if defined(__cplusplus)
}
#endif
#endif (* !_DB_EXT_PROT_IN_ *)
